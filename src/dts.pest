//! A Parsing Expression Grammar for the Devicetree Source format.
//!
//! See https://devicetree-specification.readthedocs.io/en/stable/source-language.html.

// DIFF comments mark known differences from the grammar `dtc` accepts.
//
// This grammar is not as strict as it could be.  For the sake of error
// messages on bad input, some constraints are checked at the AST level.
// For example, the exact set of characters in node/property names; `dtc`
// checks only after the tree is built, so the following produces no errors:
//   / {
//       0-9,._+*#?@;
//       0-9,._+*#?@ {};
//   };
//   / {
//       /delete-property/ 0-9,._+*#?@;
//       /delete-node/ 0-9,._+*#?@;
//   };

// Pest accepts the WHITESPACE and COMMENT rules between any other tokens
// outside an atomic rule (introduced with '@' or '$').
// We need these tokens when pretty-printing, so these rules are not silent.
WHITESPACE = { " " | "\t" | "\r" | "\n" }
// XXX why is this ${}?  is that not implied?  try removing or pushing down
COMMENT = ${ BlockComment | LineComment }
BlockComment = { "/*" ~ (BlockComment | !"*/" ~ ANY)* ~ "*/" }
// Line comments contain their own newline.  (This means we don't accept one at
// the end of a noeol file; dtc has the same restriction.)
LineComment = { "//" ~ (!newline ~ ANY)* ~ newline }
newline = _{ "\n" | "\r\n" }

DtsFile = { SOI ~ Dts ~ EOI }

/// Overall structure of a DTS file.
Dts = { Header* ~ Include* ~ Memreserve* ~ TopDef* }

// DIFF: dtc accepts #line directives (as emitted by cpp)

Semicolon = { ";" }
SlashBits = { "/bits/" }
SlashDeleteNode = { "/delete-node/" }
SlashDeleteProperty = { "/delete-property/" }
SlashDtsV1 = { "/dts-v1/" }
SlashIncbin = { "/incbin/" }
SlashInclude = { "/include/" }
SlashMemreserve = { "/memreserve/" }
SlashOmitIfNoRef = { "/omit-if-no-ref/" }
SlashPlugin = { "/plugin/" }

// DIFF: dtc requires a "/dts-v1/;" header but we make it optional,
//       to allow parsing included files with the same grammar.
Header = { Version ~ Plugin? }
Version = { SlashDtsV1 ~ Semicolon }
Plugin = { SlashPlugin ~ Semicolon }

// DIFF: accepts /include/ anywhere, not just at file scope
Include = ${ SlashInclude ~ IncludeWhitespace ~ IncludePath }
IncludeWhitespace = _{ WHITESPACE* }
// XXX why this wrapper node?
IncludePath = @{ QuotedString }

Memreserve = { Label* ~ SlashMemreserve ~ (ParenExpr | IntLiteral){2} ~ Semicolon }

// DIFF: dtc requires the first TopDef to be an unlabeled TopNode
TopDef = { TopDelNode | TopOmitNode | TopNode }
TopDelNode = { SlashDeleteNode ~ NodeReference ~ Semicolon }
TopOmitNode = { SlashOmitIfNoRef ~ NodeReference ~ Semicolon }

TopNode = { Label* ~ TopNodeName ~ NodeBody }
TopNodeName = { ( RootNodeName | NodeReference ) }
// improve error messages by avoiding a partial parse of e.g. "/dts-v1;/" as "/"
RootNodeName = @{ "/" ~ !('A'..'Z' | 'a'..'z' | '0'..'9') }

Label = @{ LabelName ~ ":" }
LabelName = @{ labelname_head ~ labelname_rest* }
labelname_head = { 'A'..'Z' | "_" | 'a'..'z' }
labelname_rest = { 'A'..'Z' | "_" | 'a'..'z' | '0'..'9' }

NodeReference = @{ ("&" ~ LabelName) | ("&{" ~ NodePath ~ "}") }

// dtc will accept and normalize node paths such as "/x///y/".
// label-relative references such as &{label/child/subnode} also work.
NodePath = @{ nodepathchar+ }
nodepathchar = { nodechar | "/" }

NodeBody = { OpenNode ~ NodeContents ~ CloseNode ~ EndNode }
OpenNode = { "{" }
CloseNode = { "}" }
EndNode = { Semicolon }
NodeContents = { PropDef* ~ ChildDef* }
PropDef = { DelProp | Prop }
ChildDef = { DelNode | ChildNode }

DelNode = { DelNodeSuperfluousPrefix? ~ SlashDeleteNode ~ NodeName ~ Semicolon }
DelNodeSuperfluousPrefix = { (Label | SlashOmitIfNoRef)* }
DelProp = { DelPropSuperfluousPrefix? ~ SlashDeleteProperty ~ PropName ~ Semicolon }
DelPropSuperfluousPrefix = { Label* }

ChildNode = { (Label | SlashOmitIfNoRef)* ~ NodeName ~ NodeBody }

NodeName = @{ "\\"? ~ nodechar+ }
// dtc accepts all of these during parsing; later validation forbids some.
nodechar = { 'A'..'Z' | 'a'..'z' | '0'..'9' | "#" | "*" | "+" | "," | "-" | "." | "?" | "@" | "_" }

Prop = { Label* ~ PropName ~ (PropAssign ~ PropValue)? ~ Semicolon }
PropAssign = { "=" }

PropName = @{ "\\"? ~ propchar+ }
// dtc accepts all of these during parsing; later validation forbids some.
propchar = { 'A'..'Z' | 'a'..'z' | '0'..'9' | "#" | "*" | "+" | "," | "-" | "." | "?" | "@" | "_" }

PropValue = { Value ~ (Comma ~ Value)* }
Comma = { "," }
Value = { Label* ~ (Cells | QuotedString | NodeReference | ByteString | Incbin) ~ Label* }

Cells = { Bits? ~ OpenCells ~ (Cell | Label)* ~ CloseCells }
Bits = { SlashBits ~ NumericLiteral }
OpenCells = { "<" }
CloseCells = { ">" }

Cell = { NodeReference | ParenExpr | IntLiteral }

// TODO: fix operator precedence with more intermediate nodes
Expr = { UnaryExpr | BinaryExpr | TernaryExpr | ParenExpr | IntLiteral }
ParenExpr = { OpenParen ~ Expr ~ CloseParen }
UnaryExpr = { UnaryOp ~ Expr }
BinaryExpr = { (ParenExpr | UnaryExpr | IntLiteral) ~ BinaryOp ~ Expr }
TernaryExpr = { (ParenExpr | UnaryExpr | IntLiteral) ~ QuestionMark ~ Expr ~ Colon ~ Expr }
UnaryOp = { LogicalNot | BitwiseNot | Negate }
BinaryOp = { BinaryArithmeticOp | BinaryLogicalOp | BinaryRelationalOp }
BinaryArithmeticOp = { Add | Subtract | Multiply | Divide | Modulus }
BinaryLogicalOp = { LogicalAnd | LogicalOr | BitwiseAnd | BitwiseOr | BitwiseXor | LeftShift | RightShift }
BinaryRelationalOp = { LessThanOrEqual | GreaterThanOrEqual | LessThan | GreaterThan | Equal | NotEqual }
OpenParen = { "(" }
CloseParen = { ")" }
QuestionMark = { "?" }
Colon = { ":" }
LogicalNot = { "!" }
BitwiseNot = { "~" }
Negate = { "-" }
Add = { "+" }
Subtract = { "-" }
Multiply = { "*" }
Divide = { "/" }
Modulus = { "%" }
LogicalAnd = { "&&" }
LogicalOr = { "||" }
BitwiseAnd = { "&" }
BitwiseOr = { "|" }
BitwiseXor = { "^" }
LeftShift = { "<<" }
RightShift = { ">>" }
LessThanOrEqual = { "<=" }
GreaterThanOrEqual = { ">=" }
LessThan = { "<" }
GreaterThan = { ">" }
Equal = { "==" }
NotEqual = { "!=" }

IntLiteral = @{ CharLiteral | NumericLiteral }

// To improve error messages, escape sequences are not fully parsed here.
// DIFF: dtc's parsing of '\\' is broken -- but only if there is a later ' in the file!
CharLiteral = @{ "'" ~ singlequotedchar* ~ "'" }
singlequotedchar = { !("'" | "\\") ~ ANY | "\\" ~ ANY }

NumericLiteral = @{ (HexLiteral | OctalLiteral | DecimalLiteral) ~ NumericSuffix? }
HexLiteral = @{ ^"0x" ~ ('0'..'9' | 'A'..'F' | 'a'..'f')* }
OctalLiteral = @{ "0" ~ ('0'..'7')* }
DecimalLiteral = @{ '1'..'9' ~ ('0'..'9')* }
NumericSuffix = { "ULL" | "LL" | "UL" | "L" | "U" }

QuotedString = @{ "\"" ~ doublequotedchar* ~ "\"" }
doublequotedchar = { !("\"" | "\\") ~ ANY | "\\" ~ ANY }

ByteString = { OpenSquare ~ (Label | HexByte)* ~ CloseSquare }
OpenSquare = { "[" }
CloseSquare = { "]" }
HexByte = @{ ('0'..'9' | 'A'..'F' | 'a'..'f'){2} }

Incbin = { SlashIncbin ~ OpenParen ~ IncbinArgs ~ CloseParen }
IncbinArgs = { QuotedString ~ (Comma ~ NumericLiteral){2}? }
