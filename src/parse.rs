//! Facilities for parsing DTS files and expanding "/include/" directives.

use crate::{Node, Property};
use pest_typed::TypedParser;
use pest_typed_derive::TypedParser;

#[derive(TypedParser)]
#[grammar = "dts.pest"]
#[emit_rule_reference]
#[box_only_if_needed]
#[simulate_pair_api]
struct DtsParser;

// TODO: rename these
pub use crate::parse::rules::dtsfile;

pub fn parse(source: &str) -> dtsfile {
    match DtsParser::try_parse::<dtsfile>(&source) {
        Ok(s) => s,
        // TODO: evaluate quality of error messages from this
        Err(err) => panic!(
            "parsing failed:\n{}",
            err.renamed_rules(|rule| format!("{:?}", rule))
        ),
    }
}

// TODO: helper function for expanding a file with includes
//

// TODO: try one of
// pest-ast (most official)
// pest_typed_derive
// pest_consume (looks worst)

// The grammar generated by pest is inconvenient to traverse, and the pest parser can't be fed
// included files mid-stream, so we use another structure to represent a combined tree.
//
// Do these need to keep pointers back to the grammar nodes?  seems likely.
//
// TODO:  lifetimes?  or translate spans to file+byterange?
// TODO:  expressions?
//
// TODO:  alternatively, we could have a design where we intermix loading the sources, evaluating
// expressions, and tree-merge operations into a single traversal.  will that be too messy?
// seems like it might be worse for error reporting.  i don't want to hear about an invalid
// expression if my includes don't work.
//
// Arguably
//
// / { x = <(0 / 0)>; };
// / { /delete-property/ x; };
//
// should be accepted, although `dtc` rejects this.

/* XXX figure out if we need this.  possibly do in order to support multiple files?
 * are there pub constructors on these things?

pub struct Dts {
    pub items: Vec<TopItem>,
}

pub enum TopItem {
    RootNode(NodeBody),
    PatchNode((Labels, NodeRef, NodeBody)),
    DeleteNode(NodeRef),
}

pub struct Labels(pub Vec<String>);

pub enum NodeRef {
    Label(String),
    Path(String),
}

pub struct NodeBody {
    pub properties: Vec<PropItem>,
    pub children: Vec<ChildItem>,
}

pub enum PropItem {
    Property((Labels, String, Option<PropValue>)),
    DeleteProperty(String),
}

pub enum ChildItem {
    Node((Labels, String, NodeBody)),
    DeleteNode(String),
}

// TODO: may want to keep a reference to the pest tree here?  i guesss it's no problem to reparse,
// but we at least need the original span for error reporting.  actually all of these should keep
// spans.  ugh.
pub struct PropValue(pub String);

// TODO: handle includes here too
pub fn expand(tree: Tree) -> Dts {
    let mut items = vec![];
    // TODO: input is a dtsfile, need the dts node
    for p in tree.into_inner() {
        match p.as_rule() {
            Rule::topnode => items.push(map_topnode(p)),
            Rule::topdelnode => items.push(map_topdelnode(p)),
            _ => eprintln!("XXX ignoring rule {:?}", p.as_rule()),
        }
    }
    Dts { items }
}

pub fn map_topnode(tree: Tree) -> TopItem {
    let key = tree.into_inner().next().unwrap();
    let body = todo!();
    let labels = todo!();
    match key.as_rule() {
        Rule::rootnode => TopItem::RootNode(map_nodebody(body)),
        Rule::noderef => TopItem::PatchNode((labels, map_noderef(key), map_nodebody(body))),
        _ => todo!(),
    }
}

pub fn map_topdelnode(tree: Tree) -> TopItem {
    // XXX need some kind of helper for "find me the next item of this type"
    // https://github.com/pest-parser/pest/issues/405
    let noderef = map_noderef(tree.into_inner().next().unwrap());
    TopItem::DeleteNode(noderef)
}

pub fn map_noderef(tree: Tree) -> NodeRef {
    todo!();
}

pub fn map_nodebody(tree: Tree) -> NodeBody {
    todo!();
}

*/
