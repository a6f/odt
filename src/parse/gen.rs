//! Typed grammar generated by pestle from /Users/ambrose/src/odt/src/dts.pest

use super::Rule;
use bumpalo::collections::Vec;
use bumpalo::Bump;
use pest::iterators::Pair;
use pest::Span;

pub trait TypedRule<'i> {
    const UNTYPED_RULE: Rule;
    fn span(&self) -> &Span<'i>;
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self;
}

fn to_singleton<T>(mut v: Vec<T>) -> T {
    match v.len() {
        1 => v.pop().unwrap(),
        n => panic!("expected exactly one item, got {n}"),
    }
}

fn to_option<T>(mut v: Vec<T>) -> Option<T> {
    match v.len() {
        0 => None,
        1 => v.pop(),
        n => panic!("expected at most one item, got {n}"),
    }
}

/// atomic rule WHITESPACE
#[derive(Debug)]
pub struct WHITESPACE<'i>(Span<'i>);

impl<'i> TypedRule<'i> for WHITESPACE<'i> {
    const UNTYPED_RULE: Rule = Rule::WHITESPACE;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// enum rule COMMENT
#[derive(Debug)]
pub enum COMMENT<'i> {
    BlockComment(&'i BlockComment<'i>),
    LineComment(&'i LineComment<'i>),
}

impl<'i> TypedRule<'i> for COMMENT<'i> {
    const UNTYPED_RULE: Rule = Rule::COMMENT;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::BlockComment(x) => x.span(),
            Self::LineComment(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::BlockComment => COMMENT::BlockComment(BlockComment::build(inner, alloc)),
            Rule::LineComment => COMMENT::LineComment(LineComment::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule BlockComment
#[derive(Debug)]
pub struct BlockComment<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BlockComment<'i> {
    const UNTYPED_RULE: Rule = Rule::BlockComment;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LineComment
#[derive(Debug)]
pub struct LineComment<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LineComment<'i> {
    const UNTYPED_RULE: Rule = Rule::LineComment;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule DtsFile
#[derive(Debug)]
pub struct DtsFile<'i> {
    pub _span: Span<'i>,
    pub dts: &'i Dts<'i>,
}

impl<'i> TypedRule<'i> for DtsFile<'i> {
    const UNTYPED_RULE: Rule = Rule::DtsFile;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_dts = Vec::<&'i Dts>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Dts => _tmp_dts.push(Dts::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            dts: to_singleton(_tmp_dts),
        })
    }
}

/// sequence rule Dts
#[derive(Debug)]
pub struct Dts<'i> {
    pub _span: Span<'i>,
    pub header: &'i Vec<'i, &'i Header<'i>>,
    pub include: &'i Vec<'i, &'i Include<'i>>,
    pub memreserve: &'i Vec<'i, &'i Memreserve<'i>>,
    pub top_def: &'i Vec<'i, &'i TopDef<'i>>,
}

impl<'i> TypedRule<'i> for Dts<'i> {
    const UNTYPED_RULE: Rule = Rule::Dts;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_header = Vec::<&'i Header>::new_in(alloc);
        let mut _tmp_include = Vec::<&'i Include>::new_in(alloc);
        let mut _tmp_memreserve = Vec::<&'i Memreserve>::new_in(alloc);
        let mut _tmp_top_def = Vec::<&'i TopDef>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Header => _tmp_header.push(Header::build(child, alloc)),
                Rule::Include => _tmp_include.push(Include::build(child, alloc)),
                Rule::Memreserve => _tmp_memreserve.push(Memreserve::build(child, alloc)),
                Rule::TopDef => _tmp_top_def.push(TopDef::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            header: alloc.alloc(_tmp_header),
            include: alloc.alloc(_tmp_include),
            memreserve: alloc.alloc(_tmp_memreserve),
            top_def: alloc.alloc(_tmp_top_def),
        })
    }
}

/// atomic rule Semicolon
#[derive(Debug)]
pub struct Semicolon<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Semicolon<'i> {
    const UNTYPED_RULE: Rule = Rule::Semicolon;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashBits
#[derive(Debug)]
pub struct SlashBits<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashBits<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashBits;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashDeleteNode
#[derive(Debug)]
pub struct SlashDeleteNode<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashDeleteNode<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashDeleteNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashDeleteProperty
#[derive(Debug)]
pub struct SlashDeleteProperty<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashDeleteProperty<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashDeleteProperty;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashDtsV1
#[derive(Debug)]
pub struct SlashDtsV1<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashDtsV1<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashDtsV1;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashIncbin
#[derive(Debug)]
pub struct SlashIncbin<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashIncbin<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashIncbin;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashInclude
#[derive(Debug)]
pub struct SlashInclude<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashInclude<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashInclude;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashMemreserve
#[derive(Debug)]
pub struct SlashMemreserve<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashMemreserve<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashMemreserve;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashOmitIfNoRef
#[derive(Debug)]
pub struct SlashOmitIfNoRef<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashOmitIfNoRef<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashOmitIfNoRef;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashPlugin
#[derive(Debug)]
pub struct SlashPlugin<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashPlugin<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashPlugin;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Header
#[derive(Debug)]
pub struct Header<'i> {
    pub _span: Span<'i>,
    pub version: &'i Version<'i>,
    pub plugin: Option<&'i Plugin<'i>>,
}

impl<'i> TypedRule<'i> for Header<'i> {
    const UNTYPED_RULE: Rule = Rule::Header;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_version = Vec::<&'i Version>::new_in(alloc);
        let mut _tmp_plugin = Vec::<&'i Plugin>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Version => _tmp_version.push(Version::build(child, alloc)),
                Rule::Plugin => _tmp_plugin.push(Plugin::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            version: to_singleton(_tmp_version),
            plugin: to_option(_tmp_plugin),
        })
    }
}

/// sequence rule Version
#[derive(Debug)]
pub struct Version<'i> {
    pub _span: Span<'i>,
    pub slash_dts_v1: &'i SlashDtsV1<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Version<'i> {
    const UNTYPED_RULE: Rule = Rule::Version;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_dts_v1 = Vec::<&'i SlashDtsV1>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashDtsV1 => _tmp_slash_dts_v1.push(SlashDtsV1::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_dts_v1: to_singleton(_tmp_slash_dts_v1),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule Plugin
#[derive(Debug)]
pub struct Plugin<'i> {
    pub _span: Span<'i>,
    pub slash_plugin: &'i SlashPlugin<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Plugin<'i> {
    const UNTYPED_RULE: Rule = Rule::Plugin;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_plugin = Vec::<&'i SlashPlugin>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashPlugin => _tmp_slash_plugin.push(SlashPlugin::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_plugin: to_singleton(_tmp_slash_plugin),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule Include
#[derive(Debug)]
pub struct Include<'i> {
    pub _span: Span<'i>,
    pub slash_include: &'i SlashInclude<'i>,
    pub include_whitespace: &'i IncludeWhitespace<'i>,
    pub quoted_string: &'i QuotedString<'i>,
}

impl<'i> TypedRule<'i> for Include<'i> {
    const UNTYPED_RULE: Rule = Rule::Include;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_include = Vec::<&'i SlashInclude>::new_in(alloc);
        let mut _tmp_include_whitespace = Vec::<&'i IncludeWhitespace>::new_in(alloc);
        let mut _tmp_quoted_string = Vec::<&'i QuotedString>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashInclude => _tmp_slash_include.push(SlashInclude::build(child, alloc)),
                Rule::IncludeWhitespace => _tmp_include_whitespace.push(IncludeWhitespace::build(child, alloc)),
                Rule::QuotedString => _tmp_quoted_string.push(QuotedString::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_include: to_singleton(_tmp_slash_include),
            include_whitespace: to_singleton(_tmp_include_whitespace),
            quoted_string: to_singleton(_tmp_quoted_string),
        })
    }
}

/// atomic rule IncludeWhitespace
#[derive(Debug)]
pub struct IncludeWhitespace<'i>(Span<'i>);

impl<'i> TypedRule<'i> for IncludeWhitespace<'i> {
    const UNTYPED_RULE: Rule = Rule::IncludeWhitespace;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Memreserve
#[derive(Debug)]
pub struct Memreserve<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub slash_memreserve: &'i SlashMemreserve<'i>,
    pub memreserve_arg: &'i Vec<'i, &'i MemreserveArg<'i>>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Memreserve<'i> {
    const UNTYPED_RULE: Rule = Rule::Memreserve;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_slash_memreserve = Vec::<&'i SlashMemreserve>::new_in(alloc);
        let mut _tmp_memreserve_arg = Vec::<&'i MemreserveArg>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::SlashMemreserve => _tmp_slash_memreserve.push(SlashMemreserve::build(child, alloc)),
                Rule::MemreserveArg => _tmp_memreserve_arg.push(MemreserveArg::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            slash_memreserve: to_singleton(_tmp_slash_memreserve),
            memreserve_arg: alloc.alloc(_tmp_memreserve_arg),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// enum rule MemreserveArg
#[derive(Debug)]
pub enum MemreserveArg<'i> {
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}

impl<'i> TypedRule<'i> for MemreserveArg<'i> {
    const UNTYPED_RULE: Rule = Rule::MemreserveArg;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::ParenExpr => MemreserveArg::ParenExpr(ParenExpr::build(inner, alloc)),
            Rule::IntLiteral => MemreserveArg::IntLiteral(IntLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule TopDef
#[derive(Debug)]
pub enum TopDef<'i> {
    TopDelNode(&'i TopDelNode<'i>),
    TopOmitNode(&'i TopOmitNode<'i>),
    TopNode(&'i TopNode<'i>),
}

impl<'i> TypedRule<'i> for TopDef<'i> {
    const UNTYPED_RULE: Rule = Rule::TopDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::TopDelNode(x) => x.span(),
            Self::TopOmitNode(x) => x.span(),
            Self::TopNode(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::TopDelNode => TopDef::TopDelNode(TopDelNode::build(inner, alloc)),
            Rule::TopOmitNode => TopDef::TopOmitNode(TopOmitNode::build(inner, alloc)),
            Rule::TopNode => TopDef::TopNode(TopNode::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule TopDelNode
#[derive(Debug)]
pub struct TopDelNode<'i> {
    pub _span: Span<'i>,
    pub slash_delete_node: &'i SlashDeleteNode<'i>,
    pub node_reference: &'i NodeReference<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for TopDelNode<'i> {
    const UNTYPED_RULE: Rule = Rule::TopDelNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_delete_node = Vec::<&'i SlashDeleteNode>::new_in(alloc);
        let mut _tmp_node_reference = Vec::<&'i NodeReference>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashDeleteNode => _tmp_slash_delete_node.push(SlashDeleteNode::build(child, alloc)),
                Rule::NodeReference => _tmp_node_reference.push(NodeReference::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_delete_node: to_singleton(_tmp_slash_delete_node),
            node_reference: to_singleton(_tmp_node_reference),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule TopOmitNode
#[derive(Debug)]
pub struct TopOmitNode<'i> {
    pub _span: Span<'i>,
    pub slash_omit_if_no_ref: &'i SlashOmitIfNoRef<'i>,
    pub node_reference: &'i NodeReference<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for TopOmitNode<'i> {
    const UNTYPED_RULE: Rule = Rule::TopOmitNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_omit_if_no_ref = Vec::<&'i SlashOmitIfNoRef>::new_in(alloc);
        let mut _tmp_node_reference = Vec::<&'i NodeReference>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashOmitIfNoRef => _tmp_slash_omit_if_no_ref.push(SlashOmitIfNoRef::build(child, alloc)),
                Rule::NodeReference => _tmp_node_reference.push(NodeReference::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_omit_if_no_ref: to_singleton(_tmp_slash_omit_if_no_ref),
            node_reference: to_singleton(_tmp_node_reference),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule TopNode
#[derive(Debug)]
pub struct TopNode<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub top_node_name: &'i TopNodeName<'i>,
    pub node_body: &'i NodeBody<'i>,
}

impl<'i> TypedRule<'i> for TopNode<'i> {
    const UNTYPED_RULE: Rule = Rule::TopNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_top_node_name = Vec::<&'i TopNodeName>::new_in(alloc);
        let mut _tmp_node_body = Vec::<&'i NodeBody>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::TopNodeName => _tmp_top_node_name.push(TopNodeName::build(child, alloc)),
                Rule::NodeBody => _tmp_node_body.push(NodeBody::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            top_node_name: to_singleton(_tmp_top_node_name),
            node_body: to_singleton(_tmp_node_body),
        })
    }
}

/// enum rule TopNodeName
#[derive(Debug)]
pub enum TopNodeName<'i> {
    RootNodeName(&'i RootNodeName<'i>),
    NodeReference(&'i NodeReference<'i>),
}

impl<'i> TypedRule<'i> for TopNodeName<'i> {
    const UNTYPED_RULE: Rule = Rule::TopNodeName;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::RootNodeName(x) => x.span(),
            Self::NodeReference(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::RootNodeName => TopNodeName::RootNodeName(RootNodeName::build(inner, alloc)),
            Rule::NodeReference => TopNodeName::NodeReference(NodeReference::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule RootNodeName
#[derive(Debug)]
pub struct RootNodeName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for RootNodeName<'i> {
    const UNTYPED_RULE: Rule = Rule::RootNodeName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Label
#[derive(Debug)]
pub struct Label<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Label<'i> {
    const UNTYPED_RULE: Rule = Rule::Label;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LabelName
#[derive(Debug)]
pub struct LabelName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LabelName<'i> {
    const UNTYPED_RULE: Rule = Rule::LabelName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NodeReference
#[derive(Debug)]
pub struct NodeReference<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NodeReference<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeReference;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NodePath
#[derive(Debug)]
pub struct NodePath<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NodePath<'i> {
    const UNTYPED_RULE: Rule = Rule::NodePath;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule NodeBody
#[derive(Debug)]
pub struct NodeBody<'i> {
    pub _span: Span<'i>,
    pub open_node: &'i OpenNode<'i>,
    pub node_contents: &'i NodeContents<'i>,
    pub close_node: &'i CloseNode<'i>,
    pub end_node: &'i EndNode<'i>,
}

impl<'i> TypedRule<'i> for NodeBody<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeBody;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_open_node = Vec::<&'i OpenNode>::new_in(alloc);
        let mut _tmp_node_contents = Vec::<&'i NodeContents>::new_in(alloc);
        let mut _tmp_close_node = Vec::<&'i CloseNode>::new_in(alloc);
        let mut _tmp_end_node = Vec::<&'i EndNode>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenNode => _tmp_open_node.push(OpenNode::build(child, alloc)),
                Rule::NodeContents => _tmp_node_contents.push(NodeContents::build(child, alloc)),
                Rule::CloseNode => _tmp_close_node.push(CloseNode::build(child, alloc)),
                Rule::EndNode => _tmp_end_node.push(EndNode::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            open_node: to_singleton(_tmp_open_node),
            node_contents: to_singleton(_tmp_node_contents),
            close_node: to_singleton(_tmp_close_node),
            end_node: to_singleton(_tmp_end_node),
        })
    }
}

/// atomic rule OpenNode
#[derive(Debug)]
pub struct OpenNode<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenNode<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseNode
#[derive(Debug)]
pub struct CloseNode<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseNode<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule EndNode
#[derive(Debug)]
pub struct EndNode<'i> {
    pub _span: Span<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for EndNode<'i> {
    const UNTYPED_RULE: Rule = Rule::EndNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule NodeContents
#[derive(Debug)]
pub struct NodeContents<'i> {
    pub _span: Span<'i>,
    pub prop_def: &'i Vec<'i, &'i PropDef<'i>>,
    pub child_def: &'i Vec<'i, &'i ChildDef<'i>>,
}

impl<'i> TypedRule<'i> for NodeContents<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeContents;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_prop_def = Vec::<&'i PropDef>::new_in(alloc);
        let mut _tmp_child_def = Vec::<&'i ChildDef>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::PropDef => _tmp_prop_def.push(PropDef::build(child, alloc)),
                Rule::ChildDef => _tmp_child_def.push(ChildDef::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            prop_def: alloc.alloc(_tmp_prop_def),
            child_def: alloc.alloc(_tmp_child_def),
        })
    }
}

/// enum rule PropDef
#[derive(Debug)]
pub enum PropDef<'i> {
    DelProp(&'i DelProp<'i>),
    Prop(&'i Prop<'i>),
}

impl<'i> TypedRule<'i> for PropDef<'i> {
    const UNTYPED_RULE: Rule = Rule::PropDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::DelProp(x) => x.span(),
            Self::Prop(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::DelProp => PropDef::DelProp(DelProp::build(inner, alloc)),
            Rule::Prop => PropDef::Prop(Prop::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule ChildDef
#[derive(Debug)]
pub enum ChildDef<'i> {
    DelNode(&'i DelNode<'i>),
    ChildNode(&'i ChildNode<'i>),
}

impl<'i> TypedRule<'i> for ChildDef<'i> {
    const UNTYPED_RULE: Rule = Rule::ChildDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::DelNode(x) => x.span(),
            Self::ChildNode(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::DelNode => ChildDef::DelNode(DelNode::build(inner, alloc)),
            Rule::ChildNode => ChildDef::ChildNode(ChildNode::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule DelNode
#[derive(Debug)]
pub struct DelNode<'i> {
    pub _span: Span<'i>,
    pub del_node_superfluous_prefix: &'i Vec<'i, &'i DelNodeSuperfluousPrefix<'i>>,
    pub slash_delete_node: &'i SlashDeleteNode<'i>,
    pub node_name: &'i NodeName<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for DelNode<'i> {
    const UNTYPED_RULE: Rule = Rule::DelNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_del_node_superfluous_prefix = Vec::<&'i DelNodeSuperfluousPrefix>::new_in(alloc);
        let mut _tmp_slash_delete_node = Vec::<&'i SlashDeleteNode>::new_in(alloc);
        let mut _tmp_node_name = Vec::<&'i NodeName>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::DelNodeSuperfluousPrefix => _tmp_del_node_superfluous_prefix.push(DelNodeSuperfluousPrefix::build(child, alloc)),
                Rule::SlashDeleteNode => _tmp_slash_delete_node.push(SlashDeleteNode::build(child, alloc)),
                Rule::NodeName => _tmp_node_name.push(NodeName::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            del_node_superfluous_prefix: alloc.alloc(_tmp_del_node_superfluous_prefix),
            slash_delete_node: to_singleton(_tmp_slash_delete_node),
            node_name: to_singleton(_tmp_node_name),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// enum rule DelNodeSuperfluousPrefix
#[derive(Debug)]
pub enum DelNodeSuperfluousPrefix<'i> {
    Label(&'i Label<'i>),
    SlashOmitIfNoRef(&'i SlashOmitIfNoRef<'i>),
}

impl<'i> TypedRule<'i> for DelNodeSuperfluousPrefix<'i> {
    const UNTYPED_RULE: Rule = Rule::DelNodeSuperfluousPrefix;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::SlashOmitIfNoRef(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => DelNodeSuperfluousPrefix::Label(Label::build(inner, alloc)),
            Rule::SlashOmitIfNoRef => DelNodeSuperfluousPrefix::SlashOmitIfNoRef(SlashOmitIfNoRef::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule DelProp
#[derive(Debug)]
pub struct DelProp<'i> {
    pub _span: Span<'i>,
    pub del_prop_superfluous_prefix: &'i Vec<'i, &'i DelPropSuperfluousPrefix<'i>>,
    pub slash_delete_property: &'i SlashDeleteProperty<'i>,
    pub prop_name: &'i PropName<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for DelProp<'i> {
    const UNTYPED_RULE: Rule = Rule::DelProp;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_del_prop_superfluous_prefix = Vec::<&'i DelPropSuperfluousPrefix>::new_in(alloc);
        let mut _tmp_slash_delete_property = Vec::<&'i SlashDeleteProperty>::new_in(alloc);
        let mut _tmp_prop_name = Vec::<&'i PropName>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::DelPropSuperfluousPrefix => _tmp_del_prop_superfluous_prefix.push(DelPropSuperfluousPrefix::build(child, alloc)),
                Rule::SlashDeleteProperty => _tmp_slash_delete_property.push(SlashDeleteProperty::build(child, alloc)),
                Rule::PropName => _tmp_prop_name.push(PropName::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            del_prop_superfluous_prefix: alloc.alloc(_tmp_del_prop_superfluous_prefix),
            slash_delete_property: to_singleton(_tmp_slash_delete_property),
            prop_name: to_singleton(_tmp_prop_name),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule DelPropSuperfluousPrefix
#[derive(Debug)]
pub struct DelPropSuperfluousPrefix<'i> {
    pub _span: Span<'i>,
    pub label: &'i Label<'i>,
}

impl<'i> TypedRule<'i> for DelPropSuperfluousPrefix<'i> {
    const UNTYPED_RULE: Rule = Rule::DelPropSuperfluousPrefix;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            label: to_singleton(_tmp_label),
        })
    }
}

/// sequence rule ChildNode
#[derive(Debug)]
pub struct ChildNode<'i> {
    pub _span: Span<'i>,
    pub child_node_prefix: &'i Vec<'i, &'i ChildNodePrefix<'i>>,
    pub node_name: &'i NodeName<'i>,
    pub node_body: &'i NodeBody<'i>,
}

impl<'i> TypedRule<'i> for ChildNode<'i> {
    const UNTYPED_RULE: Rule = Rule::ChildNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_child_node_prefix = Vec::<&'i ChildNodePrefix>::new_in(alloc);
        let mut _tmp_node_name = Vec::<&'i NodeName>::new_in(alloc);
        let mut _tmp_node_body = Vec::<&'i NodeBody>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ChildNodePrefix => _tmp_child_node_prefix.push(ChildNodePrefix::build(child, alloc)),
                Rule::NodeName => _tmp_node_name.push(NodeName::build(child, alloc)),
                Rule::NodeBody => _tmp_node_body.push(NodeBody::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            child_node_prefix: alloc.alloc(_tmp_child_node_prefix),
            node_name: to_singleton(_tmp_node_name),
            node_body: to_singleton(_tmp_node_body),
        })
    }
}

/// enum rule ChildNodePrefix
#[derive(Debug)]
pub enum ChildNodePrefix<'i> {
    Label(&'i Label<'i>),
    SlashOmitIfNoRef(&'i SlashOmitIfNoRef<'i>),
}

impl<'i> TypedRule<'i> for ChildNodePrefix<'i> {
    const UNTYPED_RULE: Rule = Rule::ChildNodePrefix;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::SlashOmitIfNoRef(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => ChildNodePrefix::Label(Label::build(inner, alloc)),
            Rule::SlashOmitIfNoRef => ChildNodePrefix::SlashOmitIfNoRef(SlashOmitIfNoRef::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule NodeName
#[derive(Debug)]
pub struct NodeName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NodeName<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Prop
#[derive(Debug)]
pub struct Prop<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub prop_name: &'i PropName<'i>,
    pub prop_assign: Option<&'i PropAssign<'i>>,
    pub prop_value: Option<&'i PropValue<'i>>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Prop<'i> {
    const UNTYPED_RULE: Rule = Rule::Prop;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_prop_name = Vec::<&'i PropName>::new_in(alloc);
        let mut _tmp_prop_assign = Vec::<&'i PropAssign>::new_in(alloc);
        let mut _tmp_prop_value = Vec::<&'i PropValue>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::PropName => _tmp_prop_name.push(PropName::build(child, alloc)),
                Rule::PropAssign => _tmp_prop_assign.push(PropAssign::build(child, alloc)),
                Rule::PropValue => _tmp_prop_value.push(PropValue::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            prop_name: to_singleton(_tmp_prop_name),
            prop_assign: to_option(_tmp_prop_assign),
            prop_value: to_option(_tmp_prop_value),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// atomic rule PropAssign
#[derive(Debug)]
pub struct PropAssign<'i>(Span<'i>);

impl<'i> TypedRule<'i> for PropAssign<'i> {
    const UNTYPED_RULE: Rule = Rule::PropAssign;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule PropName
#[derive(Debug)]
pub struct PropName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for PropName<'i> {
    const UNTYPED_RULE: Rule = Rule::PropName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule PropValue
#[derive(Debug)]
pub struct PropValue<'i> {
    pub _span: Span<'i>,
    pub labeled_value: &'i Vec<'i, &'i LabeledValue<'i>>,
    pub comma: &'i Vec<'i, &'i Comma<'i>>,
}

impl<'i> TypedRule<'i> for PropValue<'i> {
    const UNTYPED_RULE: Rule = Rule::PropValue;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_labeled_value = Vec::<&'i LabeledValue>::new_in(alloc);
        let mut _tmp_comma = Vec::<&'i Comma>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LabeledValue => _tmp_labeled_value.push(LabeledValue::build(child, alloc)),
                Rule::Comma => _tmp_comma.push(Comma::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            labeled_value: alloc.alloc(_tmp_labeled_value),
            comma: alloc.alloc(_tmp_comma),
        })
    }
}

/// atomic rule Comma
#[derive(Debug)]
pub struct Comma<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Comma<'i> {
    const UNTYPED_RULE: Rule = Rule::Comma;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule LabeledValue
#[derive(Debug)]
pub struct LabeledValue<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub value: &'i Value<'i>,
}

impl<'i> TypedRule<'i> for LabeledValue<'i> {
    const UNTYPED_RULE: Rule = Rule::LabeledValue;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_value = Vec::<&'i Value>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::Value => _tmp_value.push(Value::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            value: to_singleton(_tmp_value),
        })
    }
}

/// enum rule Value
#[derive(Debug)]
pub enum Value<'i> {
    Cells(&'i Cells<'i>),
    QuotedString(&'i QuotedString<'i>),
    NodeReference(&'i NodeReference<'i>),
    ByteString(&'i ByteString<'i>),
    Incbin(&'i Incbin<'i>),
}

impl<'i> TypedRule<'i> for Value<'i> {
    const UNTYPED_RULE: Rule = Rule::Value;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Cells(x) => x.span(),
            Self::QuotedString(x) => x.span(),
            Self::NodeReference(x) => x.span(),
            Self::ByteString(x) => x.span(),
            Self::Incbin(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Cells => Value::Cells(Cells::build(inner, alloc)),
            Rule::QuotedString => Value::QuotedString(QuotedString::build(inner, alloc)),
            Rule::NodeReference => Value::NodeReference(NodeReference::build(inner, alloc)),
            Rule::ByteString => Value::ByteString(ByteString::build(inner, alloc)),
            Rule::Incbin => Value::Incbin(Incbin::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule Cells
#[derive(Debug)]
pub struct Cells<'i> {
    pub _span: Span<'i>,
    pub bits: Option<&'i Bits<'i>>,
    pub open_cells: &'i OpenCells<'i>,
    pub label_or_cell: &'i Vec<'i, &'i LabelOrCell<'i>>,
    pub close_cells: &'i CloseCells<'i>,
}

impl<'i> TypedRule<'i> for Cells<'i> {
    const UNTYPED_RULE: Rule = Rule::Cells;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bits = Vec::<&'i Bits>::new_in(alloc);
        let mut _tmp_open_cells = Vec::<&'i OpenCells>::new_in(alloc);
        let mut _tmp_label_or_cell = Vec::<&'i LabelOrCell>::new_in(alloc);
        let mut _tmp_close_cells = Vec::<&'i CloseCells>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Bits => _tmp_bits.push(Bits::build(child, alloc)),
                Rule::OpenCells => _tmp_open_cells.push(OpenCells::build(child, alloc)),
                Rule::LabelOrCell => _tmp_label_or_cell.push(LabelOrCell::build(child, alloc)),
                Rule::CloseCells => _tmp_close_cells.push(CloseCells::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            bits: to_option(_tmp_bits),
            open_cells: to_singleton(_tmp_open_cells),
            label_or_cell: alloc.alloc(_tmp_label_or_cell),
            close_cells: to_singleton(_tmp_close_cells),
        })
    }
}

/// sequence rule Bits
#[derive(Debug)]
pub struct Bits<'i> {
    pub _span: Span<'i>,
    pub slash_bits: &'i SlashBits<'i>,
    pub numeric_literal: &'i NumericLiteral<'i>,
}

impl<'i> TypedRule<'i> for Bits<'i> {
    const UNTYPED_RULE: Rule = Rule::Bits;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_bits = Vec::<&'i SlashBits>::new_in(alloc);
        let mut _tmp_numeric_literal = Vec::<&'i NumericLiteral>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashBits => _tmp_slash_bits.push(SlashBits::build(child, alloc)),
                Rule::NumericLiteral => _tmp_numeric_literal.push(NumericLiteral::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_bits: to_singleton(_tmp_slash_bits),
            numeric_literal: to_singleton(_tmp_numeric_literal),
        })
    }
}

/// enum rule LabelOrCell
#[derive(Debug)]
pub enum LabelOrCell<'i> {
    Label(&'i Label<'i>),
    Cell(&'i Cell<'i>),
}

impl<'i> TypedRule<'i> for LabelOrCell<'i> {
    const UNTYPED_RULE: Rule = Rule::LabelOrCell;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::Cell(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => LabelOrCell::Label(Label::build(inner, alloc)),
            Rule::Cell => LabelOrCell::Cell(Cell::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule OpenCells
#[derive(Debug)]
pub struct OpenCells<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenCells<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenCells;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseCells
#[derive(Debug)]
pub struct CloseCells<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseCells<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseCells;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// enum rule Cell
#[derive(Debug)]
pub enum Cell<'i> {
    NodeReference(&'i NodeReference<'i>),
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}

impl<'i> TypedRule<'i> for Cell<'i> {
    const UNTYPED_RULE: Rule = Rule::Cell;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::NodeReference(x) => x.span(),
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::NodeReference => Cell::NodeReference(NodeReference::build(inner, alloc)),
            Rule::ParenExpr => Cell::ParenExpr(ParenExpr::build(inner, alloc)),
            Rule::IntLiteral => Cell::IntLiteral(IntLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule ParenExpr
#[derive(Debug)]
pub struct ParenExpr<'i> {
    pub _span: Span<'i>,
    pub open_paren: &'i OpenParen<'i>,
    pub expr: &'i Expr<'i>,
    pub close_paren: &'i CloseParen<'i>,
}

impl<'i> TypedRule<'i> for ParenExpr<'i> {
    const UNTYPED_RULE: Rule = Rule::ParenExpr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_open_paren = Vec::<&'i OpenParen>::new_in(alloc);
        let mut _tmp_expr = Vec::<&'i Expr>::new_in(alloc);
        let mut _tmp_close_paren = Vec::<&'i CloseParen>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenParen => _tmp_open_paren.push(OpenParen::build(child, alloc)),
                Rule::Expr => _tmp_expr.push(Expr::build(child, alloc)),
                Rule::CloseParen => _tmp_close_paren.push(CloseParen::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            open_paren: to_singleton(_tmp_open_paren),
            expr: to_singleton(_tmp_expr),
            close_paren: to_singleton(_tmp_close_paren),
        })
    }
}

/// sequence rule Expr
#[derive(Debug)]
pub struct Expr<'i> {
    pub _span: Span<'i>,
    pub ternary_prec: &'i TernaryPrec<'i>,
}

impl<'i> TypedRule<'i> for Expr<'i> {
    const UNTYPED_RULE: Rule = Rule::Expr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_ternary_prec = Vec::<&'i TernaryPrec>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::TernaryPrec => _tmp_ternary_prec.push(TernaryPrec::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            ternary_prec: to_singleton(_tmp_ternary_prec),
        })
    }
}

/// sequence rule TernaryPrec
#[derive(Debug)]
pub struct TernaryPrec<'i> {
    pub _span: Span<'i>,
    pub logical_or_prec: &'i LogicalOrPrec<'i>,
    pub question_mark: Option<&'i QuestionMark<'i>>,
    pub expr: &'i Vec<'i, &'i Expr<'i>>,
    pub colon: Option<&'i Colon<'i>>,
}

impl<'i> TypedRule<'i> for TernaryPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::TernaryPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_logical_or_prec = Vec::<&'i LogicalOrPrec>::new_in(alloc);
        let mut _tmp_question_mark = Vec::<&'i QuestionMark>::new_in(alloc);
        let mut _tmp_expr = Vec::<&'i Expr>::new_in(alloc);
        let mut _tmp_colon = Vec::<&'i Colon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LogicalOrPrec => _tmp_logical_or_prec.push(LogicalOrPrec::build(child, alloc)),
                Rule::QuestionMark => _tmp_question_mark.push(QuestionMark::build(child, alloc)),
                Rule::Expr => _tmp_expr.push(Expr::build(child, alloc)),
                Rule::Colon => _tmp_colon.push(Colon::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            logical_or_prec: to_singleton(_tmp_logical_or_prec),
            question_mark: to_option(_tmp_question_mark),
            expr: alloc.alloc(_tmp_expr),
            colon: to_option(_tmp_colon),
        })
    }
}

/// sequence rule LogicalOrPrec
#[derive(Debug)]
pub struct LogicalOrPrec<'i> {
    pub _span: Span<'i>,
    pub logical_and_prec: &'i Vec<'i, &'i LogicalAndPrec<'i>>,
    pub logical_or: &'i Vec<'i, &'i LogicalOr<'i>>,
}

impl<'i> TypedRule<'i> for LogicalOrPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalOrPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_logical_and_prec = Vec::<&'i LogicalAndPrec>::new_in(alloc);
        let mut _tmp_logical_or = Vec::<&'i LogicalOr>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LogicalAndPrec => _tmp_logical_and_prec.push(LogicalAndPrec::build(child, alloc)),
                Rule::LogicalOr => _tmp_logical_or.push(LogicalOr::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            logical_and_prec: alloc.alloc(_tmp_logical_and_prec),
            logical_or: alloc.alloc(_tmp_logical_or),
        })
    }
}

/// sequence rule LogicalAndPrec
#[derive(Debug)]
pub struct LogicalAndPrec<'i> {
    pub _span: Span<'i>,
    pub bitwise_or_prec: &'i Vec<'i, &'i BitwiseOrPrec<'i>>,
    pub logical_and: &'i Vec<'i, &'i LogicalAnd<'i>>,
}

impl<'i> TypedRule<'i> for LogicalAndPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalAndPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwise_or_prec = Vec::<&'i BitwiseOrPrec>::new_in(alloc);
        let mut _tmp_logical_and = Vec::<&'i LogicalAnd>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseOrPrec => _tmp_bitwise_or_prec.push(BitwiseOrPrec::build(child, alloc)),
                Rule::LogicalAnd => _tmp_logical_and.push(LogicalAnd::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            bitwise_or_prec: alloc.alloc(_tmp_bitwise_or_prec),
            logical_and: alloc.alloc(_tmp_logical_and),
        })
    }
}

/// sequence rule BitwiseOrPrec
#[derive(Debug)]
pub struct BitwiseOrPrec<'i> {
    pub _span: Span<'i>,
    pub bitwise_xor_prec: &'i Vec<'i, &'i BitwiseXorPrec<'i>>,
    pub bitwise_or: &'i Vec<'i, &'i BitwiseOr<'i>>,
}

impl<'i> TypedRule<'i> for BitwiseOrPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseOrPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwise_xor_prec = Vec::<&'i BitwiseXorPrec>::new_in(alloc);
        let mut _tmp_bitwise_or = Vec::<&'i BitwiseOr>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseXorPrec => _tmp_bitwise_xor_prec.push(BitwiseXorPrec::build(child, alloc)),
                Rule::BitwiseOr => _tmp_bitwise_or.push(BitwiseOr::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            bitwise_xor_prec: alloc.alloc(_tmp_bitwise_xor_prec),
            bitwise_or: alloc.alloc(_tmp_bitwise_or),
        })
    }
}

/// sequence rule BitwiseXorPrec
#[derive(Debug)]
pub struct BitwiseXorPrec<'i> {
    pub _span: Span<'i>,
    pub bitwise_and_prec: &'i Vec<'i, &'i BitwiseAndPrec<'i>>,
    pub bitwise_xor: &'i Vec<'i, &'i BitwiseXor<'i>>,
}

impl<'i> TypedRule<'i> for BitwiseXorPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseXorPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwise_and_prec = Vec::<&'i BitwiseAndPrec>::new_in(alloc);
        let mut _tmp_bitwise_xor = Vec::<&'i BitwiseXor>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseAndPrec => _tmp_bitwise_and_prec.push(BitwiseAndPrec::build(child, alloc)),
                Rule::BitwiseXor => _tmp_bitwise_xor.push(BitwiseXor::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            bitwise_and_prec: alloc.alloc(_tmp_bitwise_and_prec),
            bitwise_xor: alloc.alloc(_tmp_bitwise_xor),
        })
    }
}

/// sequence rule BitwiseAndPrec
#[derive(Debug)]
pub struct BitwiseAndPrec<'i> {
    pub _span: Span<'i>,
    pub equal_prec: &'i Vec<'i, &'i EqualPrec<'i>>,
    pub bitwise_and: &'i Vec<'i, &'i BitwiseAnd<'i>>,
}

impl<'i> TypedRule<'i> for BitwiseAndPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseAndPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_equal_prec = Vec::<&'i EqualPrec>::new_in(alloc);
        let mut _tmp_bitwise_and = Vec::<&'i BitwiseAnd>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::EqualPrec => _tmp_equal_prec.push(EqualPrec::build(child, alloc)),
                Rule::BitwiseAnd => _tmp_bitwise_and.push(BitwiseAnd::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            equal_prec: alloc.alloc(_tmp_equal_prec),
            bitwise_and: alloc.alloc(_tmp_bitwise_and),
        })
    }
}

/// sequence rule EqualPrec
#[derive(Debug)]
pub struct EqualPrec<'i> {
    pub _span: Span<'i>,
    pub compare_prec: &'i Vec<'i, &'i ComparePrec<'i>>,
    pub equal_prec_op: &'i Vec<'i, &'i EqualPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for EqualPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::EqualPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_compare_prec = Vec::<&'i ComparePrec>::new_in(alloc);
        let mut _tmp_equal_prec_op = Vec::<&'i EqualPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ComparePrec => _tmp_compare_prec.push(ComparePrec::build(child, alloc)),
                Rule::EqualPrecOp => _tmp_equal_prec_op.push(EqualPrecOp::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            compare_prec: alloc.alloc(_tmp_compare_prec),
            equal_prec_op: alloc.alloc(_tmp_equal_prec_op),
        })
    }
}

/// sequence rule ComparePrec
#[derive(Debug)]
pub struct ComparePrec<'i> {
    pub _span: Span<'i>,
    pub shift_prec: &'i Vec<'i, &'i ShiftPrec<'i>>,
    pub compare_prec_op: &'i Vec<'i, &'i ComparePrecOp<'i>>,
}

impl<'i> TypedRule<'i> for ComparePrec<'i> {
    const UNTYPED_RULE: Rule = Rule::ComparePrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_shift_prec = Vec::<&'i ShiftPrec>::new_in(alloc);
        let mut _tmp_compare_prec_op = Vec::<&'i ComparePrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ShiftPrec => _tmp_shift_prec.push(ShiftPrec::build(child, alloc)),
                Rule::ComparePrecOp => _tmp_compare_prec_op.push(ComparePrecOp::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            shift_prec: alloc.alloc(_tmp_shift_prec),
            compare_prec_op: alloc.alloc(_tmp_compare_prec_op),
        })
    }
}

/// sequence rule ShiftPrec
#[derive(Debug)]
pub struct ShiftPrec<'i> {
    pub _span: Span<'i>,
    pub add_prec: &'i Vec<'i, &'i AddPrec<'i>>,
    pub shift_prec_op: &'i Vec<'i, &'i ShiftPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for ShiftPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::ShiftPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_add_prec = Vec::<&'i AddPrec>::new_in(alloc);
        let mut _tmp_shift_prec_op = Vec::<&'i ShiftPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::AddPrec => _tmp_add_prec.push(AddPrec::build(child, alloc)),
                Rule::ShiftPrecOp => _tmp_shift_prec_op.push(ShiftPrecOp::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            add_prec: alloc.alloc(_tmp_add_prec),
            shift_prec_op: alloc.alloc(_tmp_shift_prec_op),
        })
    }
}

/// sequence rule AddPrec
#[derive(Debug)]
pub struct AddPrec<'i> {
    pub _span: Span<'i>,
    pub mul_prec: &'i Vec<'i, &'i MulPrec<'i>>,
    pub add_prec_op: &'i Vec<'i, &'i AddPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for AddPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::AddPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_mul_prec = Vec::<&'i MulPrec>::new_in(alloc);
        let mut _tmp_add_prec_op = Vec::<&'i AddPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::MulPrec => _tmp_mul_prec.push(MulPrec::build(child, alloc)),
                Rule::AddPrecOp => _tmp_add_prec_op.push(AddPrecOp::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            mul_prec: alloc.alloc(_tmp_mul_prec),
            add_prec_op: alloc.alloc(_tmp_add_prec_op),
        })
    }
}

/// sequence rule MulPrec
#[derive(Debug)]
pub struct MulPrec<'i> {
    pub _span: Span<'i>,
    pub unary_prec: &'i Vec<'i, &'i UnaryPrec<'i>>,
    pub mul_prec_op: &'i Vec<'i, &'i MulPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for MulPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::MulPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_unary_prec = Vec::<&'i UnaryPrec>::new_in(alloc);
        let mut _tmp_mul_prec_op = Vec::<&'i MulPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::UnaryPrec => _tmp_unary_prec.push(UnaryPrec::build(child, alloc)),
                Rule::MulPrecOp => _tmp_mul_prec_op.push(MulPrecOp::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            unary_prec: alloc.alloc(_tmp_unary_prec),
            mul_prec_op: alloc.alloc(_tmp_mul_prec_op),
        })
    }
}

/// enum rule UnaryPrec
#[derive(Debug)]
pub enum UnaryPrec<'i> {
    UnaryExpr(&'i UnaryExpr<'i>),
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}

impl<'i> TypedRule<'i> for UnaryPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::UnaryPrec;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::UnaryExpr(x) => x.span(),
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::UnaryExpr => UnaryPrec::UnaryExpr(UnaryExpr::build(inner, alloc)),
            Rule::ParenExpr => UnaryPrec::ParenExpr(ParenExpr::build(inner, alloc)),
            Rule::IntLiteral => UnaryPrec::IntLiteral(IntLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule UnaryExpr
#[derive(Debug)]
pub struct UnaryExpr<'i> {
    pub _span: Span<'i>,
    pub unary_op: &'i UnaryOp<'i>,
    pub unary_prec: &'i UnaryPrec<'i>,
}

impl<'i> TypedRule<'i> for UnaryExpr<'i> {
    const UNTYPED_RULE: Rule = Rule::UnaryExpr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_unary_op = Vec::<&'i UnaryOp>::new_in(alloc);
        let mut _tmp_unary_prec = Vec::<&'i UnaryPrec>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::UnaryOp => _tmp_unary_op.push(UnaryOp::build(child, alloc)),
                Rule::UnaryPrec => _tmp_unary_prec.push(UnaryPrec::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            unary_op: to_singleton(_tmp_unary_op),
            unary_prec: to_singleton(_tmp_unary_prec),
        })
    }
}

/// enum rule EqualPrecOp
#[derive(Debug)]
pub enum EqualPrecOp<'i> {
    Equal(&'i Equal<'i>),
    NotEqual(&'i NotEqual<'i>),
}

impl<'i> TypedRule<'i> for EqualPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::EqualPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Equal(x) => x.span(),
            Self::NotEqual(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Equal => EqualPrecOp::Equal(Equal::build(inner, alloc)),
            Rule::NotEqual => EqualPrecOp::NotEqual(NotEqual::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule ComparePrecOp
#[derive(Debug)]
pub enum ComparePrecOp<'i> {
    LessThanOrEqual(&'i LessThanOrEqual<'i>),
    GreaterThanOrEqual(&'i GreaterThanOrEqual<'i>),
    LessThan(&'i LessThan<'i>),
    GreaterThan(&'i GreaterThan<'i>),
}

impl<'i> TypedRule<'i> for ComparePrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::ComparePrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LessThanOrEqual(x) => x.span(),
            Self::GreaterThanOrEqual(x) => x.span(),
            Self::LessThan(x) => x.span(),
            Self::GreaterThan(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::LessThanOrEqual => ComparePrecOp::LessThanOrEqual(LessThanOrEqual::build(inner, alloc)),
            Rule::GreaterThanOrEqual => ComparePrecOp::GreaterThanOrEqual(GreaterThanOrEqual::build(inner, alloc)),
            Rule::LessThan => ComparePrecOp::LessThan(LessThan::build(inner, alloc)),
            Rule::GreaterThan => ComparePrecOp::GreaterThan(GreaterThan::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule ShiftPrecOp
#[derive(Debug)]
pub enum ShiftPrecOp<'i> {
    LeftShift(&'i LeftShift<'i>),
    RightShift(&'i RightShift<'i>),
}

impl<'i> TypedRule<'i> for ShiftPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::ShiftPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LeftShift(x) => x.span(),
            Self::RightShift(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::LeftShift => ShiftPrecOp::LeftShift(LeftShift::build(inner, alloc)),
            Rule::RightShift => ShiftPrecOp::RightShift(RightShift::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule AddPrecOp
#[derive(Debug)]
pub enum AddPrecOp<'i> {
    Add(&'i Add<'i>),
    Subtract(&'i Subtract<'i>),
}

impl<'i> TypedRule<'i> for AddPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::AddPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Add(x) => x.span(),
            Self::Subtract(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Add => AddPrecOp::Add(Add::build(inner, alloc)),
            Rule::Subtract => AddPrecOp::Subtract(Subtract::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule MulPrecOp
#[derive(Debug)]
pub enum MulPrecOp<'i> {
    Multiply(&'i Multiply<'i>),
    Divide(&'i Divide<'i>),
    Modulus(&'i Modulus<'i>),
}

impl<'i> TypedRule<'i> for MulPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::MulPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Multiply(x) => x.span(),
            Self::Divide(x) => x.span(),
            Self::Modulus(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Multiply => MulPrecOp::Multiply(Multiply::build(inner, alloc)),
            Rule::Divide => MulPrecOp::Divide(Divide::build(inner, alloc)),
            Rule::Modulus => MulPrecOp::Modulus(Modulus::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule UnaryOp
#[derive(Debug)]
pub enum UnaryOp<'i> {
    LogicalNot(&'i LogicalNot<'i>),
    BitwiseNot(&'i BitwiseNot<'i>),
    Negate(&'i Negate<'i>),
}

impl<'i> TypedRule<'i> for UnaryOp<'i> {
    const UNTYPED_RULE: Rule = Rule::UnaryOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LogicalNot(x) => x.span(),
            Self::BitwiseNot(x) => x.span(),
            Self::Negate(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::LogicalNot => UnaryOp::LogicalNot(LogicalNot::build(inner, alloc)),
            Rule::BitwiseNot => UnaryOp::BitwiseNot(BitwiseNot::build(inner, alloc)),
            Rule::Negate => UnaryOp::Negate(Negate::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule OpenParen
#[derive(Debug)]
pub struct OpenParen<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenParen<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenParen;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseParen
#[derive(Debug)]
pub struct CloseParen<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseParen<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseParen;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule QuestionMark
#[derive(Debug)]
pub struct QuestionMark<'i>(Span<'i>);

impl<'i> TypedRule<'i> for QuestionMark<'i> {
    const UNTYPED_RULE: Rule = Rule::QuestionMark;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Colon
#[derive(Debug)]
pub struct Colon<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Colon<'i> {
    const UNTYPED_RULE: Rule = Rule::Colon;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LogicalNot
#[derive(Debug)]
pub struct LogicalNot<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LogicalNot<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalNot;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseNot
#[derive(Debug)]
pub struct BitwiseNot<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseNot<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseNot;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Negate
#[derive(Debug)]
pub struct Negate<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Negate<'i> {
    const UNTYPED_RULE: Rule = Rule::Negate;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Add
#[derive(Debug)]
pub struct Add<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Add<'i> {
    const UNTYPED_RULE: Rule = Rule::Add;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Subtract
#[derive(Debug)]
pub struct Subtract<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Subtract<'i> {
    const UNTYPED_RULE: Rule = Rule::Subtract;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Multiply
#[derive(Debug)]
pub struct Multiply<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Multiply<'i> {
    const UNTYPED_RULE: Rule = Rule::Multiply;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Divide
#[derive(Debug)]
pub struct Divide<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Divide<'i> {
    const UNTYPED_RULE: Rule = Rule::Divide;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Modulus
#[derive(Debug)]
pub struct Modulus<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Modulus<'i> {
    const UNTYPED_RULE: Rule = Rule::Modulus;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LogicalAnd
#[derive(Debug)]
pub struct LogicalAnd<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LogicalAnd<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalAnd;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LogicalOr
#[derive(Debug)]
pub struct LogicalOr<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LogicalOr<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalOr;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseAnd
#[derive(Debug)]
pub struct BitwiseAnd<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseAnd<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseAnd;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseOr
#[derive(Debug)]
pub struct BitwiseOr<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseOr<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseOr;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseXor
#[derive(Debug)]
pub struct BitwiseXor<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseXor<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseXor;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LeftShift
#[derive(Debug)]
pub struct LeftShift<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LeftShift<'i> {
    const UNTYPED_RULE: Rule = Rule::LeftShift;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule RightShift
#[derive(Debug)]
pub struct RightShift<'i>(Span<'i>);

impl<'i> TypedRule<'i> for RightShift<'i> {
    const UNTYPED_RULE: Rule = Rule::RightShift;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LessThanOrEqual
#[derive(Debug)]
pub struct LessThanOrEqual<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LessThanOrEqual<'i> {
    const UNTYPED_RULE: Rule = Rule::LessThanOrEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule GreaterThanOrEqual
#[derive(Debug)]
pub struct GreaterThanOrEqual<'i>(Span<'i>);

impl<'i> TypedRule<'i> for GreaterThanOrEqual<'i> {
    const UNTYPED_RULE: Rule = Rule::GreaterThanOrEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LessThan
#[derive(Debug)]
pub struct LessThan<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LessThan<'i> {
    const UNTYPED_RULE: Rule = Rule::LessThan;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule GreaterThan
#[derive(Debug)]
pub struct GreaterThan<'i>(Span<'i>);

impl<'i> TypedRule<'i> for GreaterThan<'i> {
    const UNTYPED_RULE: Rule = Rule::GreaterThan;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Equal
#[derive(Debug)]
pub struct Equal<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Equal<'i> {
    const UNTYPED_RULE: Rule = Rule::Equal;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NotEqual
#[derive(Debug)]
pub struct NotEqual<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NotEqual<'i> {
    const UNTYPED_RULE: Rule = Rule::NotEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// enum rule IntLiteral
#[derive(Debug)]
pub enum IntLiteral<'i> {
    CharLiteral(&'i CharLiteral<'i>),
    NumericLiteral(&'i NumericLiteral<'i>),
}

impl<'i> TypedRule<'i> for IntLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::IntLiteral;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::CharLiteral(x) => x.span(),
            Self::NumericLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::CharLiteral => IntLiteral::CharLiteral(CharLiteral::build(inner, alloc)),
            Rule::NumericLiteral => IntLiteral::NumericLiteral(NumericLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule CharLiteral
#[derive(Debug)]
pub struct CharLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CharLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::CharLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NumericLiteral
#[derive(Debug)]
pub struct NumericLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NumericLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::NumericLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule HexLiteral
#[derive(Debug)]
pub struct HexLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for HexLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::HexLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule OctalLiteral
#[derive(Debug)]
pub struct OctalLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OctalLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::OctalLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule DecimalLiteral
#[derive(Debug)]
pub struct DecimalLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for DecimalLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::DecimalLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NumericSuffix
#[derive(Debug)]
pub struct NumericSuffix<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NumericSuffix<'i> {
    const UNTYPED_RULE: Rule = Rule::NumericSuffix;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule QuotedString
#[derive(Debug)]
pub struct QuotedString<'i>(Span<'i>);

impl<'i> TypedRule<'i> for QuotedString<'i> {
    const UNTYPED_RULE: Rule = Rule::QuotedString;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule ByteString
#[derive(Debug)]
pub struct ByteString<'i> {
    pub _span: Span<'i>,
    pub open_square: &'i OpenSquare<'i>,
    pub label_or_hex_byte: &'i Vec<'i, &'i LabelOrHexByte<'i>>,
    pub close_square: &'i CloseSquare<'i>,
}

impl<'i> TypedRule<'i> for ByteString<'i> {
    const UNTYPED_RULE: Rule = Rule::ByteString;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_open_square = Vec::<&'i OpenSquare>::new_in(alloc);
        let mut _tmp_label_or_hex_byte = Vec::<&'i LabelOrHexByte>::new_in(alloc);
        let mut _tmp_close_square = Vec::<&'i CloseSquare>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenSquare => _tmp_open_square.push(OpenSquare::build(child, alloc)),
                Rule::LabelOrHexByte => _tmp_label_or_hex_byte.push(LabelOrHexByte::build(child, alloc)),
                Rule::CloseSquare => _tmp_close_square.push(CloseSquare::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            open_square: to_singleton(_tmp_open_square),
            label_or_hex_byte: alloc.alloc(_tmp_label_or_hex_byte),
            close_square: to_singleton(_tmp_close_square),
        })
    }
}

/// enum rule LabelOrHexByte
#[derive(Debug)]
pub enum LabelOrHexByte<'i> {
    Label(&'i Label<'i>),
    HexByte(&'i HexByte<'i>),
}

impl<'i> TypedRule<'i> for LabelOrHexByte<'i> {
    const UNTYPED_RULE: Rule = Rule::LabelOrHexByte;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::HexByte(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => LabelOrHexByte::Label(Label::build(inner, alloc)),
            Rule::HexByte => LabelOrHexByte::HexByte(HexByte::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule OpenSquare
#[derive(Debug)]
pub struct OpenSquare<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenSquare<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenSquare;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseSquare
#[derive(Debug)]
pub struct CloseSquare<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseSquare<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseSquare;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule HexByte
#[derive(Debug)]
pub struct HexByte<'i>(Span<'i>);

impl<'i> TypedRule<'i> for HexByte<'i> {
    const UNTYPED_RULE: Rule = Rule::HexByte;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Incbin
#[derive(Debug)]
pub struct Incbin<'i> {
    pub _span: Span<'i>,
    pub slash_incbin: &'i SlashIncbin<'i>,
    pub open_paren: &'i OpenParen<'i>,
    pub incbin_args: &'i IncbinArgs<'i>,
    pub close_paren: &'i CloseParen<'i>,
}

impl<'i> TypedRule<'i> for Incbin<'i> {
    const UNTYPED_RULE: Rule = Rule::Incbin;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_incbin = Vec::<&'i SlashIncbin>::new_in(alloc);
        let mut _tmp_open_paren = Vec::<&'i OpenParen>::new_in(alloc);
        let mut _tmp_incbin_args = Vec::<&'i IncbinArgs>::new_in(alloc);
        let mut _tmp_close_paren = Vec::<&'i CloseParen>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashIncbin => _tmp_slash_incbin.push(SlashIncbin::build(child, alloc)),
                Rule::OpenParen => _tmp_open_paren.push(OpenParen::build(child, alloc)),
                Rule::IncbinArgs => _tmp_incbin_args.push(IncbinArgs::build(child, alloc)),
                Rule::CloseParen => _tmp_close_paren.push(CloseParen::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            slash_incbin: to_singleton(_tmp_slash_incbin),
            open_paren: to_singleton(_tmp_open_paren),
            incbin_args: to_singleton(_tmp_incbin_args),
            close_paren: to_singleton(_tmp_close_paren),
        })
    }
}

/// sequence rule IncbinArgs
#[derive(Debug)]
pub struct IncbinArgs<'i> {
    pub _span: Span<'i>,
    pub quoted_string: &'i QuotedString<'i>,
    pub comma: &'i Vec<'i, &'i Comma<'i>>,
    pub numeric_literal: &'i Vec<'i, &'i NumericLiteral<'i>>,
}

impl<'i> TypedRule<'i> for IncbinArgs<'i> {
    const UNTYPED_RULE: Rule = Rule::IncbinArgs;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_quoted_string = Vec::<&'i QuotedString>::new_in(alloc);
        let mut _tmp_comma = Vec::<&'i Comma>::new_in(alloc);
        let mut _tmp_numeric_literal = Vec::<&'i NumericLiteral>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::QuotedString => _tmp_quoted_string.push(QuotedString::build(child, alloc)),
                Rule::Comma => _tmp_comma.push(Comma::build(child, alloc)),
                Rule::NumericLiteral => _tmp_numeric_literal.push(NumericLiteral::build(child, alloc)),
                _ => (),
            }
        }
        alloc.alloc(Self {
            _span,
            quoted_string: to_singleton(_tmp_quoted_string),
            comma: alloc.alloc(_tmp_comma),
            numeric_literal: alloc.alloc(_tmp_numeric_literal),
        })
    }
}
