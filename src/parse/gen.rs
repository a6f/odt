//! Typed grammar generated by pestle from /Users/ambrose/src/odt/src/dts.pest

use super::Rule;
use bumpalo::collections::Vec;
use bumpalo::Bump;
use pest::iterators::Pair;
use pest::Span;

pub trait TypedRule<'i> {
    const UNTYPED_RULE: Rule;
    fn span(&self) -> &Span<'i>;
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self;
}

fn to_singleton<T>(mut v: Vec<T>) -> T {
    match v.len() {
        1 => v.pop().unwrap(),
        n => panic!("expected exactly one item, got {n}"),
    }
}

fn to_option<T>(mut v: Vec<T>) -> Option<T> {
    match v.len() {
        0 => None,
        1 => v.pop(),
        n => panic!("expected at most one item, got {n}"),
    }
}

// applied PESTLE_SKIP



/// atomic rule BlockComment
#[derive(Debug)]
pub struct BlockComment<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BlockComment<'i> {
    const UNTYPED_RULE: Rule = Rule::BlockComment;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LineComment
#[derive(Debug)]
pub struct LineComment<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LineComment<'i> {
    const UNTYPED_RULE: Rule = Rule::LineComment;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule newline generates no code

/// sequence rule DtsFile
#[derive(Debug)]
pub struct DtsFile<'i> {
    pub _span: Span<'i>,
    pub dts: &'i Dts<'i>,
}

impl<'i> TypedRule<'i> for DtsFile<'i> {
    const UNTYPED_RULE: Rule = Rule::DtsFile;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_dts = Vec::<&'i Dts>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Dts => _tmp_dts.push(Dts::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            dts: to_singleton(_tmp_dts),
        })
    }
}

/// sequence rule Dts
#[derive(Debug)]
pub struct Dts<'i> {
    pub _span: Span<'i>,
    pub header: &'i Vec<'i, &'i Header<'i>>,
    pub include: &'i Vec<'i, &'i Include<'i>>,
    pub memreserve: &'i Vec<'i, &'i Memreserve<'i>>,
    pub topdef: &'i Vec<'i, &'i TopDef<'i>>,
}

impl<'i> TypedRule<'i> for Dts<'i> {
    const UNTYPED_RULE: Rule = Rule::Dts;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_header = Vec::<&'i Header>::new_in(alloc);
        let mut _tmp_include = Vec::<&'i Include>::new_in(alloc);
        let mut _tmp_memreserve = Vec::<&'i Memreserve>::new_in(alloc);
        let mut _tmp_topdef = Vec::<&'i TopDef>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Header => _tmp_header.push(Header::build(child, alloc)),
                Rule::Include => _tmp_include.push(Include::build(child, alloc)),
                Rule::Memreserve => _tmp_memreserve.push(Memreserve::build(child, alloc)),
                Rule::TopDef => _tmp_topdef.push(TopDef::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            header: alloc.alloc(_tmp_header),
            include: alloc.alloc(_tmp_include),
            memreserve: alloc.alloc(_tmp_memreserve),
            topdef: alloc.alloc(_tmp_topdef),
        })
    }
}

/// atomic rule Semicolon
#[derive(Debug)]
pub struct Semicolon<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Semicolon<'i> {
    const UNTYPED_RULE: Rule = Rule::Semicolon;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashBits
#[derive(Debug)]
pub struct SlashBits<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashBits<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashBits;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashDeleteNode
#[derive(Debug)]
pub struct SlashDeleteNode<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashDeleteNode<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashDeleteNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashDeleteProperty
#[derive(Debug)]
pub struct SlashDeleteProperty<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashDeleteProperty<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashDeleteProperty;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashDtsV1
#[derive(Debug)]
pub struct SlashDtsV1<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashDtsV1<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashDtsV1;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashIncbin
#[derive(Debug)]
pub struct SlashIncbin<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashIncbin<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashIncbin;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashInclude
#[derive(Debug)]
pub struct SlashInclude<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashInclude<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashInclude;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashMemreserve
#[derive(Debug)]
pub struct SlashMemreserve<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashMemreserve<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashMemreserve;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashOmitIfNoRef
#[derive(Debug)]
pub struct SlashOmitIfNoRef<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashOmitIfNoRef<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashOmitIfNoRef;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule SlashPlugin
#[derive(Debug)]
pub struct SlashPlugin<'i>(Span<'i>);

impl<'i> TypedRule<'i> for SlashPlugin<'i> {
    const UNTYPED_RULE: Rule = Rule::SlashPlugin;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Header
#[derive(Debug)]
pub struct Header<'i> {
    pub _span: Span<'i>,
    pub version: &'i Version<'i>,
    pub plugin: Option<&'i Plugin<'i>>,
}

impl<'i> TypedRule<'i> for Header<'i> {
    const UNTYPED_RULE: Rule = Rule::Header;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_version = Vec::<&'i Version>::new_in(alloc);
        let mut _tmp_plugin = Vec::<&'i Plugin>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Version => _tmp_version.push(Version::build(child, alloc)),
                Rule::Plugin => _tmp_plugin.push(Plugin::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            version: to_singleton(_tmp_version),
            plugin: to_option(_tmp_plugin),
        })
    }
}

/// sequence rule Version
#[derive(Debug)]
pub struct Version<'i> {
    pub _span: Span<'i>,
    pub slashdtsv1: &'i SlashDtsV1<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Version<'i> {
    const UNTYPED_RULE: Rule = Rule::Version;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashdtsv1 = Vec::<&'i SlashDtsV1>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashDtsV1 => _tmp_slashdtsv1.push(SlashDtsV1::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashdtsv1: to_singleton(_tmp_slashdtsv1),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule Plugin
#[derive(Debug)]
pub struct Plugin<'i> {
    pub _span: Span<'i>,
    pub slashplugin: &'i SlashPlugin<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Plugin<'i> {
    const UNTYPED_RULE: Rule = Rule::Plugin;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashplugin = Vec::<&'i SlashPlugin>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashPlugin => _tmp_slashplugin.push(SlashPlugin::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashplugin: to_singleton(_tmp_slashplugin),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule Include
#[derive(Debug)]
pub struct Include<'i> {
    pub _span: Span<'i>,
    pub slashinclude: &'i SlashInclude<'i>,
    pub includewhitespace: &'i IncludeWhitespace<'i>,
    pub quotedstring: &'i QuotedString<'i>,
}

impl<'i> TypedRule<'i> for Include<'i> {
    const UNTYPED_RULE: Rule = Rule::Include;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashinclude = Vec::<&'i SlashInclude>::new_in(alloc);
        let mut _tmp_includewhitespace = Vec::<&'i IncludeWhitespace>::new_in(alloc);
        let mut _tmp_quotedstring = Vec::<&'i QuotedString>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashInclude => _tmp_slashinclude.push(SlashInclude::build(child, alloc)),
                Rule::IncludeWhitespace => _tmp_includewhitespace.push(IncludeWhitespace::build(child, alloc)),
                Rule::QuotedString => _tmp_quotedstring.push(QuotedString::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashinclude: to_singleton(_tmp_slashinclude),
            includewhitespace: to_singleton(_tmp_includewhitespace),
            quotedstring: to_singleton(_tmp_quotedstring),
        })
    }
}

/// atomic rule IncludeWhitespace
#[derive(Debug)]
pub struct IncludeWhitespace<'i>(Span<'i>);

impl<'i> TypedRule<'i> for IncludeWhitespace<'i> {
    const UNTYPED_RULE: Rule = Rule::IncludeWhitespace;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Memreserve
#[derive(Debug)]
pub struct Memreserve<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub slashmemreserve: &'i SlashMemreserve<'i>,
    pub memreservearg: &'i Vec<'i, &'i MemreserveArg<'i>>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Memreserve<'i> {
    const UNTYPED_RULE: Rule = Rule::Memreserve;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_slashmemreserve = Vec::<&'i SlashMemreserve>::new_in(alloc);
        let mut _tmp_memreservearg = Vec::<&'i MemreserveArg>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::SlashMemreserve => _tmp_slashmemreserve.push(SlashMemreserve::build(child, alloc)),
                Rule::MemreserveArg => _tmp_memreservearg.push(MemreserveArg::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            slashmemreserve: to_singleton(_tmp_slashmemreserve),
            memreservearg: alloc.alloc(_tmp_memreservearg),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// enum rule MemreserveArg
#[derive(Debug)]
pub enum MemreserveArg<'i> {
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}

impl<'i> TypedRule<'i> for MemreserveArg<'i> {
    const UNTYPED_RULE: Rule = Rule::MemreserveArg;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::ParenExpr => MemreserveArg::ParenExpr(ParenExpr::build(inner, alloc)),
            Rule::IntLiteral => MemreserveArg::IntLiteral(IntLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule TopDef
#[derive(Debug)]
pub enum TopDef<'i> {
    TopDelNode(&'i TopDelNode<'i>),
    TopOmitNode(&'i TopOmitNode<'i>),
    TopNode(&'i TopNode<'i>),
}

impl<'i> TypedRule<'i> for TopDef<'i> {
    const UNTYPED_RULE: Rule = Rule::TopDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::TopDelNode(x) => x.span(),
            Self::TopOmitNode(x) => x.span(),
            Self::TopNode(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::TopDelNode => TopDef::TopDelNode(TopDelNode::build(inner, alloc)),
            Rule::TopOmitNode => TopDef::TopOmitNode(TopOmitNode::build(inner, alloc)),
            Rule::TopNode => TopDef::TopNode(TopNode::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule TopDelNode
#[derive(Debug)]
pub struct TopDelNode<'i> {
    pub _span: Span<'i>,
    pub slashdeletenode: &'i SlashDeleteNode<'i>,
    pub nodereference: &'i NodeReference<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for TopDelNode<'i> {
    const UNTYPED_RULE: Rule = Rule::TopDelNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashdeletenode = Vec::<&'i SlashDeleteNode>::new_in(alloc);
        let mut _tmp_nodereference = Vec::<&'i NodeReference>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashDeleteNode => _tmp_slashdeletenode.push(SlashDeleteNode::build(child, alloc)),
                Rule::NodeReference => _tmp_nodereference.push(NodeReference::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashdeletenode: to_singleton(_tmp_slashdeletenode),
            nodereference: to_singleton(_tmp_nodereference),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule TopOmitNode
#[derive(Debug)]
pub struct TopOmitNode<'i> {
    pub _span: Span<'i>,
    pub slashomitifnoref: &'i SlashOmitIfNoRef<'i>,
    pub nodereference: &'i NodeReference<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for TopOmitNode<'i> {
    const UNTYPED_RULE: Rule = Rule::TopOmitNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashomitifnoref = Vec::<&'i SlashOmitIfNoRef>::new_in(alloc);
        let mut _tmp_nodereference = Vec::<&'i NodeReference>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashOmitIfNoRef => _tmp_slashomitifnoref.push(SlashOmitIfNoRef::build(child, alloc)),
                Rule::NodeReference => _tmp_nodereference.push(NodeReference::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashomitifnoref: to_singleton(_tmp_slashomitifnoref),
            nodereference: to_singleton(_tmp_nodereference),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule TopNode
#[derive(Debug)]
pub struct TopNode<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub topnodename: &'i TopNodeName<'i>,
    pub nodebody: &'i NodeBody<'i>,
}

impl<'i> TypedRule<'i> for TopNode<'i> {
    const UNTYPED_RULE: Rule = Rule::TopNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_topnodename = Vec::<&'i TopNodeName>::new_in(alloc);
        let mut _tmp_nodebody = Vec::<&'i NodeBody>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::TopNodeName => _tmp_topnodename.push(TopNodeName::build(child, alloc)),
                Rule::NodeBody => _tmp_nodebody.push(NodeBody::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            topnodename: to_singleton(_tmp_topnodename),
            nodebody: to_singleton(_tmp_nodebody),
        })
    }
}

/// enum rule TopNodeName
#[derive(Debug)]
pub enum TopNodeName<'i> {
    RootNodeName(&'i RootNodeName<'i>),
    NodeReference(&'i NodeReference<'i>),
}

impl<'i> TypedRule<'i> for TopNodeName<'i> {
    const UNTYPED_RULE: Rule = Rule::TopNodeName;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::RootNodeName(x) => x.span(),
            Self::NodeReference(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::RootNodeName => TopNodeName::RootNodeName(RootNodeName::build(inner, alloc)),
            Rule::NodeReference => TopNodeName::NodeReference(NodeReference::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule RootNodeName
#[derive(Debug)]
pub struct RootNodeName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for RootNodeName<'i> {
    const UNTYPED_RULE: Rule = Rule::RootNodeName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Label
#[derive(Debug)]
pub struct Label<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Label<'i> {
    const UNTYPED_RULE: Rule = Rule::Label;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LabelName
#[derive(Debug)]
pub struct LabelName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LabelName<'i> {
    const UNTYPED_RULE: Rule = Rule::LabelName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule labelname_head generates no code

// silent rule labelname_rest generates no code

/// atomic rule NodeReference
#[derive(Debug)]
pub struct NodeReference<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NodeReference<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeReference;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NodePath
#[derive(Debug)]
pub struct NodePath<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NodePath<'i> {
    const UNTYPED_RULE: Rule = Rule::NodePath;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule nodepathchar generates no code

/// sequence rule NodeBody
#[derive(Debug)]
pub struct NodeBody<'i> {
    pub _span: Span<'i>,
    pub opennode: &'i OpenNode<'i>,
    pub nodecontents: &'i NodeContents<'i>,
    pub closenode: &'i CloseNode<'i>,
    pub endnode: &'i EndNode<'i>,
}

impl<'i> TypedRule<'i> for NodeBody<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeBody;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_opennode = Vec::<&'i OpenNode>::new_in(alloc);
        let mut _tmp_nodecontents = Vec::<&'i NodeContents>::new_in(alloc);
        let mut _tmp_closenode = Vec::<&'i CloseNode>::new_in(alloc);
        let mut _tmp_endnode = Vec::<&'i EndNode>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenNode => _tmp_opennode.push(OpenNode::build(child, alloc)),
                Rule::NodeContents => _tmp_nodecontents.push(NodeContents::build(child, alloc)),
                Rule::CloseNode => _tmp_closenode.push(CloseNode::build(child, alloc)),
                Rule::EndNode => _tmp_endnode.push(EndNode::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            opennode: to_singleton(_tmp_opennode),
            nodecontents: to_singleton(_tmp_nodecontents),
            closenode: to_singleton(_tmp_closenode),
            endnode: to_singleton(_tmp_endnode),
        })
    }
}

/// atomic rule OpenNode
#[derive(Debug)]
pub struct OpenNode<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenNode<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseNode
#[derive(Debug)]
pub struct CloseNode<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseNode<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule EndNode
#[derive(Debug)]
pub struct EndNode<'i> {
    pub _span: Span<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for EndNode<'i> {
    const UNTYPED_RULE: Rule = Rule::EndNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule NodeContents
#[derive(Debug)]
pub struct NodeContents<'i> {
    pub _span: Span<'i>,
    pub propdef: &'i Vec<'i, &'i PropDef<'i>>,
    pub childdef: &'i Vec<'i, &'i ChildDef<'i>>,
}

impl<'i> TypedRule<'i> for NodeContents<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeContents;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_propdef = Vec::<&'i PropDef>::new_in(alloc);
        let mut _tmp_childdef = Vec::<&'i ChildDef>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::PropDef => _tmp_propdef.push(PropDef::build(child, alloc)),
                Rule::ChildDef => _tmp_childdef.push(ChildDef::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            propdef: alloc.alloc(_tmp_propdef),
            childdef: alloc.alloc(_tmp_childdef),
        })
    }
}

/// enum rule PropDef
#[derive(Debug)]
pub enum PropDef<'i> {
    DelProp(&'i DelProp<'i>),
    Prop(&'i Prop<'i>),
}

impl<'i> TypedRule<'i> for PropDef<'i> {
    const UNTYPED_RULE: Rule = Rule::PropDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::DelProp(x) => x.span(),
            Self::Prop(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::DelProp => PropDef::DelProp(DelProp::build(inner, alloc)),
            Rule::Prop => PropDef::Prop(Prop::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule ChildDef
#[derive(Debug)]
pub enum ChildDef<'i> {
    DelNode(&'i DelNode<'i>),
    ChildNode(&'i ChildNode<'i>),
}

impl<'i> TypedRule<'i> for ChildDef<'i> {
    const UNTYPED_RULE: Rule = Rule::ChildDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::DelNode(x) => x.span(),
            Self::ChildNode(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::DelNode => ChildDef::DelNode(DelNode::build(inner, alloc)),
            Rule::ChildNode => ChildDef::ChildNode(ChildNode::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule DelNode
#[derive(Debug)]
pub struct DelNode<'i> {
    pub _span: Span<'i>,
    pub delnodesuperfluousprefix: &'i Vec<'i, &'i DelNodeSuperfluousPrefix<'i>>,
    pub slashdeletenode: &'i SlashDeleteNode<'i>,
    pub nodename: &'i NodeName<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for DelNode<'i> {
    const UNTYPED_RULE: Rule = Rule::DelNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_delnodesuperfluousprefix = Vec::<&'i DelNodeSuperfluousPrefix>::new_in(alloc);
        let mut _tmp_slashdeletenode = Vec::<&'i SlashDeleteNode>::new_in(alloc);
        let mut _tmp_nodename = Vec::<&'i NodeName>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::DelNodeSuperfluousPrefix => _tmp_delnodesuperfluousprefix.push(DelNodeSuperfluousPrefix::build(child, alloc)),
                Rule::SlashDeleteNode => _tmp_slashdeletenode.push(SlashDeleteNode::build(child, alloc)),
                Rule::NodeName => _tmp_nodename.push(NodeName::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            delnodesuperfluousprefix: alloc.alloc(_tmp_delnodesuperfluousprefix),
            slashdeletenode: to_singleton(_tmp_slashdeletenode),
            nodename: to_singleton(_tmp_nodename),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// enum rule DelNodeSuperfluousPrefix
#[derive(Debug)]
pub enum DelNodeSuperfluousPrefix<'i> {
    Label(&'i Label<'i>),
    SlashOmitIfNoRef(&'i SlashOmitIfNoRef<'i>),
}

impl<'i> TypedRule<'i> for DelNodeSuperfluousPrefix<'i> {
    const UNTYPED_RULE: Rule = Rule::DelNodeSuperfluousPrefix;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::SlashOmitIfNoRef(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => DelNodeSuperfluousPrefix::Label(Label::build(inner, alloc)),
            Rule::SlashOmitIfNoRef => DelNodeSuperfluousPrefix::SlashOmitIfNoRef(SlashOmitIfNoRef::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule DelProp
#[derive(Debug)]
pub struct DelProp<'i> {
    pub _span: Span<'i>,
    pub delpropsuperfluousprefix: &'i Vec<'i, &'i DelPropSuperfluousPrefix<'i>>,
    pub slashdeleteproperty: &'i SlashDeleteProperty<'i>,
    pub propname: &'i PropName<'i>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for DelProp<'i> {
    const UNTYPED_RULE: Rule = Rule::DelProp;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_delpropsuperfluousprefix = Vec::<&'i DelPropSuperfluousPrefix>::new_in(alloc);
        let mut _tmp_slashdeleteproperty = Vec::<&'i SlashDeleteProperty>::new_in(alloc);
        let mut _tmp_propname = Vec::<&'i PropName>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::DelPropSuperfluousPrefix => _tmp_delpropsuperfluousprefix.push(DelPropSuperfluousPrefix::build(child, alloc)),
                Rule::SlashDeleteProperty => _tmp_slashdeleteproperty.push(SlashDeleteProperty::build(child, alloc)),
                Rule::PropName => _tmp_propname.push(PropName::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            delpropsuperfluousprefix: alloc.alloc(_tmp_delpropsuperfluousprefix),
            slashdeleteproperty: to_singleton(_tmp_slashdeleteproperty),
            propname: to_singleton(_tmp_propname),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// sequence rule DelPropSuperfluousPrefix
#[derive(Debug)]
pub struct DelPropSuperfluousPrefix<'i> {
    pub _span: Span<'i>,
    pub label: &'i Label<'i>,
}

impl<'i> TypedRule<'i> for DelPropSuperfluousPrefix<'i> {
    const UNTYPED_RULE: Rule = Rule::DelPropSuperfluousPrefix;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            label: to_singleton(_tmp_label),
        })
    }
}

/// sequence rule ChildNode
#[derive(Debug)]
pub struct ChildNode<'i> {
    pub _span: Span<'i>,
    pub childnodeprefix: &'i Vec<'i, &'i ChildNodePrefix<'i>>,
    pub nodename: &'i NodeName<'i>,
    pub nodebody: &'i NodeBody<'i>,
}

impl<'i> TypedRule<'i> for ChildNode<'i> {
    const UNTYPED_RULE: Rule = Rule::ChildNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_childnodeprefix = Vec::<&'i ChildNodePrefix>::new_in(alloc);
        let mut _tmp_nodename = Vec::<&'i NodeName>::new_in(alloc);
        let mut _tmp_nodebody = Vec::<&'i NodeBody>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ChildNodePrefix => _tmp_childnodeprefix.push(ChildNodePrefix::build(child, alloc)),
                Rule::NodeName => _tmp_nodename.push(NodeName::build(child, alloc)),
                Rule::NodeBody => _tmp_nodebody.push(NodeBody::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            childnodeprefix: alloc.alloc(_tmp_childnodeprefix),
            nodename: to_singleton(_tmp_nodename),
            nodebody: to_singleton(_tmp_nodebody),
        })
    }
}

/// enum rule ChildNodePrefix
#[derive(Debug)]
pub enum ChildNodePrefix<'i> {
    Label(&'i Label<'i>),
    SlashOmitIfNoRef(&'i SlashOmitIfNoRef<'i>),
}

impl<'i> TypedRule<'i> for ChildNodePrefix<'i> {
    const UNTYPED_RULE: Rule = Rule::ChildNodePrefix;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::SlashOmitIfNoRef(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => ChildNodePrefix::Label(Label::build(inner, alloc)),
            Rule::SlashOmitIfNoRef => ChildNodePrefix::SlashOmitIfNoRef(SlashOmitIfNoRef::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule NodeName
#[derive(Debug)]
pub struct NodeName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NodeName<'i> {
    const UNTYPED_RULE: Rule = Rule::NodeName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule nodechar generates no code

/// sequence rule Prop
#[derive(Debug)]
pub struct Prop<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub propname: &'i PropName<'i>,
    pub propassign: Option<&'i PropAssign<'i>>,
    pub propvalue: Option<&'i PropValue<'i>>,
    pub semicolon: &'i Semicolon<'i>,
}

impl<'i> TypedRule<'i> for Prop<'i> {
    const UNTYPED_RULE: Rule = Rule::Prop;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_propname = Vec::<&'i PropName>::new_in(alloc);
        let mut _tmp_propassign = Vec::<&'i PropAssign>::new_in(alloc);
        let mut _tmp_propvalue = Vec::<&'i PropValue>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::PropName => _tmp_propname.push(PropName::build(child, alloc)),
                Rule::PropAssign => _tmp_propassign.push(PropAssign::build(child, alloc)),
                Rule::PropValue => _tmp_propvalue.push(PropValue::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            propname: to_singleton(_tmp_propname),
            propassign: to_option(_tmp_propassign),
            propvalue: to_option(_tmp_propvalue),
            semicolon: to_singleton(_tmp_semicolon),
        })
    }
}

/// atomic rule PropAssign
#[derive(Debug)]
pub struct PropAssign<'i>(Span<'i>);

impl<'i> TypedRule<'i> for PropAssign<'i> {
    const UNTYPED_RULE: Rule = Rule::PropAssign;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule PropName
#[derive(Debug)]
pub struct PropName<'i>(Span<'i>);

impl<'i> TypedRule<'i> for PropName<'i> {
    const UNTYPED_RULE: Rule = Rule::PropName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule propchar generates no code

/// sequence rule PropValue
#[derive(Debug)]
pub struct PropValue<'i> {
    pub _span: Span<'i>,
    pub labeledvalue: &'i Vec<'i, &'i LabeledValue<'i>>,
    pub comma: &'i Vec<'i, &'i Comma<'i>>,
}

impl<'i> TypedRule<'i> for PropValue<'i> {
    const UNTYPED_RULE: Rule = Rule::PropValue;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_labeledvalue = Vec::<&'i LabeledValue>::new_in(alloc);
        let mut _tmp_comma = Vec::<&'i Comma>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LabeledValue => _tmp_labeledvalue.push(LabeledValue::build(child, alloc)),
                Rule::Comma => _tmp_comma.push(Comma::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            labeledvalue: alloc.alloc(_tmp_labeledvalue),
            comma: alloc.alloc(_tmp_comma),
        })
    }
}

/// atomic rule Comma
#[derive(Debug)]
pub struct Comma<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Comma<'i> {
    const UNTYPED_RULE: Rule = Rule::Comma;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule LabeledValue
#[derive(Debug)]
pub struct LabeledValue<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub value: &'i Value<'i>,
}

impl<'i> TypedRule<'i> for LabeledValue<'i> {
    const UNTYPED_RULE: Rule = Rule::LabeledValue;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_value = Vec::<&'i Value>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::Value => _tmp_value.push(Value::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            label: alloc.alloc(_tmp_label),
            value: to_singleton(_tmp_value),
        })
    }
}

/// enum rule Value
#[derive(Debug)]
pub enum Value<'i> {
    Cells(&'i Cells<'i>),
    QuotedString(&'i QuotedString<'i>),
    NodeReference(&'i NodeReference<'i>),
    ByteString(&'i ByteString<'i>),
    Incbin(&'i Incbin<'i>),
}

impl<'i> TypedRule<'i> for Value<'i> {
    const UNTYPED_RULE: Rule = Rule::Value;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Cells(x) => x.span(),
            Self::QuotedString(x) => x.span(),
            Self::NodeReference(x) => x.span(),
            Self::ByteString(x) => x.span(),
            Self::Incbin(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Cells => Value::Cells(Cells::build(inner, alloc)),
            Rule::QuotedString => Value::QuotedString(QuotedString::build(inner, alloc)),
            Rule::NodeReference => Value::NodeReference(NodeReference::build(inner, alloc)),
            Rule::ByteString => Value::ByteString(ByteString::build(inner, alloc)),
            Rule::Incbin => Value::Incbin(Incbin::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule Cells
#[derive(Debug)]
pub struct Cells<'i> {
    pub _span: Span<'i>,
    pub bits: Option<&'i Bits<'i>>,
    pub opencells: &'i OpenCells<'i>,
    pub labelorcell: &'i Vec<'i, &'i LabelOrCell<'i>>,
    pub closecells: &'i CloseCells<'i>,
}

impl<'i> TypedRule<'i> for Cells<'i> {
    const UNTYPED_RULE: Rule = Rule::Cells;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bits = Vec::<&'i Bits>::new_in(alloc);
        let mut _tmp_opencells = Vec::<&'i OpenCells>::new_in(alloc);
        let mut _tmp_labelorcell = Vec::<&'i LabelOrCell>::new_in(alloc);
        let mut _tmp_closecells = Vec::<&'i CloseCells>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Bits => _tmp_bits.push(Bits::build(child, alloc)),
                Rule::OpenCells => _tmp_opencells.push(OpenCells::build(child, alloc)),
                Rule::LabelOrCell => _tmp_labelorcell.push(LabelOrCell::build(child, alloc)),
                Rule::CloseCells => _tmp_closecells.push(CloseCells::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            bits: to_option(_tmp_bits),
            opencells: to_singleton(_tmp_opencells),
            labelorcell: alloc.alloc(_tmp_labelorcell),
            closecells: to_singleton(_tmp_closecells),
        })
    }
}

/// sequence rule Bits
#[derive(Debug)]
pub struct Bits<'i> {
    pub _span: Span<'i>,
    pub slashbits: &'i SlashBits<'i>,
    pub numericliteral: &'i NumericLiteral<'i>,
}

impl<'i> TypedRule<'i> for Bits<'i> {
    const UNTYPED_RULE: Rule = Rule::Bits;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashbits = Vec::<&'i SlashBits>::new_in(alloc);
        let mut _tmp_numericliteral = Vec::<&'i NumericLiteral>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashBits => _tmp_slashbits.push(SlashBits::build(child, alloc)),
                Rule::NumericLiteral => _tmp_numericliteral.push(NumericLiteral::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashbits: to_singleton(_tmp_slashbits),
            numericliteral: to_singleton(_tmp_numericliteral),
        })
    }
}

/// enum rule LabelOrCell
#[derive(Debug)]
pub enum LabelOrCell<'i> {
    Label(&'i Label<'i>),
    Cell(&'i Cell<'i>),
}

impl<'i> TypedRule<'i> for LabelOrCell<'i> {
    const UNTYPED_RULE: Rule = Rule::LabelOrCell;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::Cell(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => LabelOrCell::Label(Label::build(inner, alloc)),
            Rule::Cell => LabelOrCell::Cell(Cell::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule OpenCells
#[derive(Debug)]
pub struct OpenCells<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenCells<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenCells;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseCells
#[derive(Debug)]
pub struct CloseCells<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseCells<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseCells;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// enum rule Cell
#[derive(Debug)]
pub enum Cell<'i> {
    NodeReference(&'i NodeReference<'i>),
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}

impl<'i> TypedRule<'i> for Cell<'i> {
    const UNTYPED_RULE: Rule = Rule::Cell;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::NodeReference(x) => x.span(),
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::NodeReference => Cell::NodeReference(NodeReference::build(inner, alloc)),
            Rule::ParenExpr => Cell::ParenExpr(ParenExpr::build(inner, alloc)),
            Rule::IntLiteral => Cell::IntLiteral(IntLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule ParenExpr
#[derive(Debug)]
pub struct ParenExpr<'i> {
    pub _span: Span<'i>,
    pub openparen: &'i OpenParen<'i>,
    pub expr: &'i Expr<'i>,
    pub closeparen: &'i CloseParen<'i>,
}

impl<'i> TypedRule<'i> for ParenExpr<'i> {
    const UNTYPED_RULE: Rule = Rule::ParenExpr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_openparen = Vec::<&'i OpenParen>::new_in(alloc);
        let mut _tmp_expr = Vec::<&'i Expr>::new_in(alloc);
        let mut _tmp_closeparen = Vec::<&'i CloseParen>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenParen => _tmp_openparen.push(OpenParen::build(child, alloc)),
                Rule::Expr => _tmp_expr.push(Expr::build(child, alloc)),
                Rule::CloseParen => _tmp_closeparen.push(CloseParen::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            openparen: to_singleton(_tmp_openparen),
            expr: to_singleton(_tmp_expr),
            closeparen: to_singleton(_tmp_closeparen),
        })
    }
}

/// sequence rule Expr
#[derive(Debug)]
pub struct Expr<'i> {
    pub _span: Span<'i>,
    pub ternaryprec: &'i TernaryPrec<'i>,
}

impl<'i> TypedRule<'i> for Expr<'i> {
    const UNTYPED_RULE: Rule = Rule::Expr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_ternaryprec = Vec::<&'i TernaryPrec>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::TernaryPrec => _tmp_ternaryprec.push(TernaryPrec::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            ternaryprec: to_singleton(_tmp_ternaryprec),
        })
    }
}

/// sequence rule TernaryPrec
#[derive(Debug)]
pub struct TernaryPrec<'i> {
    pub _span: Span<'i>,
    pub logicalorprec: &'i LogicalOrPrec<'i>,
    pub questionmark: Option<&'i QuestionMark<'i>>,
    pub expr: &'i Vec<'i, &'i Expr<'i>>,
    pub colon: Option<&'i Colon<'i>>,
}

impl<'i> TypedRule<'i> for TernaryPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::TernaryPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_logicalorprec = Vec::<&'i LogicalOrPrec>::new_in(alloc);
        let mut _tmp_questionmark = Vec::<&'i QuestionMark>::new_in(alloc);
        let mut _tmp_expr = Vec::<&'i Expr>::new_in(alloc);
        let mut _tmp_colon = Vec::<&'i Colon>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LogicalOrPrec => _tmp_logicalorprec.push(LogicalOrPrec::build(child, alloc)),
                Rule::QuestionMark => _tmp_questionmark.push(QuestionMark::build(child, alloc)),
                Rule::Expr => _tmp_expr.push(Expr::build(child, alloc)),
                Rule::Colon => _tmp_colon.push(Colon::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            logicalorprec: to_singleton(_tmp_logicalorprec),
            questionmark: to_option(_tmp_questionmark),
            expr: alloc.alloc(_tmp_expr),
            colon: to_option(_tmp_colon),
        })
    }
}

/// sequence rule LogicalOrPrec
#[derive(Debug)]
pub struct LogicalOrPrec<'i> {
    pub _span: Span<'i>,
    pub logicalandprec: &'i Vec<'i, &'i LogicalAndPrec<'i>>,
    pub logicalor: &'i Vec<'i, &'i LogicalOr<'i>>,
}

impl<'i> TypedRule<'i> for LogicalOrPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalOrPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_logicalandprec = Vec::<&'i LogicalAndPrec>::new_in(alloc);
        let mut _tmp_logicalor = Vec::<&'i LogicalOr>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LogicalAndPrec => _tmp_logicalandprec.push(LogicalAndPrec::build(child, alloc)),
                Rule::LogicalOr => _tmp_logicalor.push(LogicalOr::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            logicalandprec: alloc.alloc(_tmp_logicalandprec),
            logicalor: alloc.alloc(_tmp_logicalor),
        })
    }
}

/// sequence rule LogicalAndPrec
#[derive(Debug)]
pub struct LogicalAndPrec<'i> {
    pub _span: Span<'i>,
    pub bitwiseorprec: &'i Vec<'i, &'i BitwiseOrPrec<'i>>,
    pub logicaland: &'i Vec<'i, &'i LogicalAnd<'i>>,
}

impl<'i> TypedRule<'i> for LogicalAndPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalAndPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwiseorprec = Vec::<&'i BitwiseOrPrec>::new_in(alloc);
        let mut _tmp_logicaland = Vec::<&'i LogicalAnd>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseOrPrec => _tmp_bitwiseorprec.push(BitwiseOrPrec::build(child, alloc)),
                Rule::LogicalAnd => _tmp_logicaland.push(LogicalAnd::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            bitwiseorprec: alloc.alloc(_tmp_bitwiseorprec),
            logicaland: alloc.alloc(_tmp_logicaland),
        })
    }
}

/// sequence rule BitwiseOrPrec
#[derive(Debug)]
pub struct BitwiseOrPrec<'i> {
    pub _span: Span<'i>,
    pub bitwisexorprec: &'i Vec<'i, &'i BitwiseXorPrec<'i>>,
    pub bitwiseor: &'i Vec<'i, &'i BitwiseOr<'i>>,
}

impl<'i> TypedRule<'i> for BitwiseOrPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseOrPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwisexorprec = Vec::<&'i BitwiseXorPrec>::new_in(alloc);
        let mut _tmp_bitwiseor = Vec::<&'i BitwiseOr>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseXorPrec => _tmp_bitwisexorprec.push(BitwiseXorPrec::build(child, alloc)),
                Rule::BitwiseOr => _tmp_bitwiseor.push(BitwiseOr::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            bitwisexorprec: alloc.alloc(_tmp_bitwisexorprec),
            bitwiseor: alloc.alloc(_tmp_bitwiseor),
        })
    }
}

/// sequence rule BitwiseXorPrec
#[derive(Debug)]
pub struct BitwiseXorPrec<'i> {
    pub _span: Span<'i>,
    pub bitwiseandprec: &'i Vec<'i, &'i BitwiseAndPrec<'i>>,
    pub bitwisexor: &'i Vec<'i, &'i BitwiseXor<'i>>,
}

impl<'i> TypedRule<'i> for BitwiseXorPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseXorPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwiseandprec = Vec::<&'i BitwiseAndPrec>::new_in(alloc);
        let mut _tmp_bitwisexor = Vec::<&'i BitwiseXor>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseAndPrec => _tmp_bitwiseandprec.push(BitwiseAndPrec::build(child, alloc)),
                Rule::BitwiseXor => _tmp_bitwisexor.push(BitwiseXor::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            bitwiseandprec: alloc.alloc(_tmp_bitwiseandprec),
            bitwisexor: alloc.alloc(_tmp_bitwisexor),
        })
    }
}

/// sequence rule BitwiseAndPrec
#[derive(Debug)]
pub struct BitwiseAndPrec<'i> {
    pub _span: Span<'i>,
    pub equalprec: &'i Vec<'i, &'i EqualPrec<'i>>,
    pub bitwiseand: &'i Vec<'i, &'i BitwiseAnd<'i>>,
}

impl<'i> TypedRule<'i> for BitwiseAndPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseAndPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_equalprec = Vec::<&'i EqualPrec>::new_in(alloc);
        let mut _tmp_bitwiseand = Vec::<&'i BitwiseAnd>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::EqualPrec => _tmp_equalprec.push(EqualPrec::build(child, alloc)),
                Rule::BitwiseAnd => _tmp_bitwiseand.push(BitwiseAnd::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            equalprec: alloc.alloc(_tmp_equalprec),
            bitwiseand: alloc.alloc(_tmp_bitwiseand),
        })
    }
}

/// sequence rule EqualPrec
#[derive(Debug)]
pub struct EqualPrec<'i> {
    pub _span: Span<'i>,
    pub compareprec: &'i Vec<'i, &'i ComparePrec<'i>>,
    pub equalprecop: &'i Vec<'i, &'i EqualPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for EqualPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::EqualPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_compareprec = Vec::<&'i ComparePrec>::new_in(alloc);
        let mut _tmp_equalprecop = Vec::<&'i EqualPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ComparePrec => _tmp_compareprec.push(ComparePrec::build(child, alloc)),
                Rule::EqualPrecOp => _tmp_equalprecop.push(EqualPrecOp::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            compareprec: alloc.alloc(_tmp_compareprec),
            equalprecop: alloc.alloc(_tmp_equalprecop),
        })
    }
}

/// sequence rule ComparePrec
#[derive(Debug)]
pub struct ComparePrec<'i> {
    pub _span: Span<'i>,
    pub shiftprec: &'i Vec<'i, &'i ShiftPrec<'i>>,
    pub compareprecop: &'i Vec<'i, &'i ComparePrecOp<'i>>,
}

impl<'i> TypedRule<'i> for ComparePrec<'i> {
    const UNTYPED_RULE: Rule = Rule::ComparePrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_shiftprec = Vec::<&'i ShiftPrec>::new_in(alloc);
        let mut _tmp_compareprecop = Vec::<&'i ComparePrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ShiftPrec => _tmp_shiftprec.push(ShiftPrec::build(child, alloc)),
                Rule::ComparePrecOp => _tmp_compareprecop.push(ComparePrecOp::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            shiftprec: alloc.alloc(_tmp_shiftprec),
            compareprecop: alloc.alloc(_tmp_compareprecop),
        })
    }
}

/// sequence rule ShiftPrec
#[derive(Debug)]
pub struct ShiftPrec<'i> {
    pub _span: Span<'i>,
    pub addprec: &'i Vec<'i, &'i AddPrec<'i>>,
    pub shiftprecop: &'i Vec<'i, &'i ShiftPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for ShiftPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::ShiftPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_addprec = Vec::<&'i AddPrec>::new_in(alloc);
        let mut _tmp_shiftprecop = Vec::<&'i ShiftPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::AddPrec => _tmp_addprec.push(AddPrec::build(child, alloc)),
                Rule::ShiftPrecOp => _tmp_shiftprecop.push(ShiftPrecOp::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            addprec: alloc.alloc(_tmp_addprec),
            shiftprecop: alloc.alloc(_tmp_shiftprecop),
        })
    }
}

/// sequence rule AddPrec
#[derive(Debug)]
pub struct AddPrec<'i> {
    pub _span: Span<'i>,
    pub mulprec: &'i Vec<'i, &'i MulPrec<'i>>,
    pub addprecop: &'i Vec<'i, &'i AddPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for AddPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::AddPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_mulprec = Vec::<&'i MulPrec>::new_in(alloc);
        let mut _tmp_addprecop = Vec::<&'i AddPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::MulPrec => _tmp_mulprec.push(MulPrec::build(child, alloc)),
                Rule::AddPrecOp => _tmp_addprecop.push(AddPrecOp::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            mulprec: alloc.alloc(_tmp_mulprec),
            addprecop: alloc.alloc(_tmp_addprecop),
        })
    }
}

/// sequence rule MulPrec
#[derive(Debug)]
pub struct MulPrec<'i> {
    pub _span: Span<'i>,
    pub unaryprec: &'i Vec<'i, &'i UnaryPrec<'i>>,
    pub mulprecop: &'i Vec<'i, &'i MulPrecOp<'i>>,
}

impl<'i> TypedRule<'i> for MulPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::MulPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_unaryprec = Vec::<&'i UnaryPrec>::new_in(alloc);
        let mut _tmp_mulprecop = Vec::<&'i MulPrecOp>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::UnaryPrec => _tmp_unaryprec.push(UnaryPrec::build(child, alloc)),
                Rule::MulPrecOp => _tmp_mulprecop.push(MulPrecOp::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            unaryprec: alloc.alloc(_tmp_unaryprec),
            mulprecop: alloc.alloc(_tmp_mulprecop),
        })
    }
}

/// enum rule UnaryPrec
#[derive(Debug)]
pub enum UnaryPrec<'i> {
    UnaryExpr(&'i UnaryExpr<'i>),
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}

impl<'i> TypedRule<'i> for UnaryPrec<'i> {
    const UNTYPED_RULE: Rule = Rule::UnaryPrec;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::UnaryExpr(x) => x.span(),
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::UnaryExpr => UnaryPrec::UnaryExpr(UnaryExpr::build(inner, alloc)),
            Rule::ParenExpr => UnaryPrec::ParenExpr(ParenExpr::build(inner, alloc)),
            Rule::IntLiteral => UnaryPrec::IntLiteral(IntLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// sequence rule UnaryExpr
#[derive(Debug)]
pub struct UnaryExpr<'i> {
    pub _span: Span<'i>,
    pub unaryop: &'i UnaryOp<'i>,
    pub unaryprec: &'i UnaryPrec<'i>,
}

impl<'i> TypedRule<'i> for UnaryExpr<'i> {
    const UNTYPED_RULE: Rule = Rule::UnaryExpr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_unaryop = Vec::<&'i UnaryOp>::new_in(alloc);
        let mut _tmp_unaryprec = Vec::<&'i UnaryPrec>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::UnaryOp => _tmp_unaryop.push(UnaryOp::build(child, alloc)),
                Rule::UnaryPrec => _tmp_unaryprec.push(UnaryPrec::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            unaryop: to_singleton(_tmp_unaryop),
            unaryprec: to_singleton(_tmp_unaryprec),
        })
    }
}

/// enum rule EqualPrecOp
#[derive(Debug)]
pub enum EqualPrecOp<'i> {
    Equal(&'i Equal<'i>),
    NotEqual(&'i NotEqual<'i>),
}

impl<'i> TypedRule<'i> for EqualPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::EqualPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Equal(x) => x.span(),
            Self::NotEqual(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Equal => EqualPrecOp::Equal(Equal::build(inner, alloc)),
            Rule::NotEqual => EqualPrecOp::NotEqual(NotEqual::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule ComparePrecOp
#[derive(Debug)]
pub enum ComparePrecOp<'i> {
    LessThanOrEqual(&'i LessThanOrEqual<'i>),
    GreaterThanOrEqual(&'i GreaterThanOrEqual<'i>),
    LessThan(&'i LessThan<'i>),
    GreaterThan(&'i GreaterThan<'i>),
}

impl<'i> TypedRule<'i> for ComparePrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::ComparePrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LessThanOrEqual(x) => x.span(),
            Self::GreaterThanOrEqual(x) => x.span(),
            Self::LessThan(x) => x.span(),
            Self::GreaterThan(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::LessThanOrEqual => ComparePrecOp::LessThanOrEqual(LessThanOrEqual::build(inner, alloc)),
            Rule::GreaterThanOrEqual => ComparePrecOp::GreaterThanOrEqual(GreaterThanOrEqual::build(inner, alloc)),
            Rule::LessThan => ComparePrecOp::LessThan(LessThan::build(inner, alloc)),
            Rule::GreaterThan => ComparePrecOp::GreaterThan(GreaterThan::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule ShiftPrecOp
#[derive(Debug)]
pub enum ShiftPrecOp<'i> {
    LeftShift(&'i LeftShift<'i>),
    RightShift(&'i RightShift<'i>),
}

impl<'i> TypedRule<'i> for ShiftPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::ShiftPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LeftShift(x) => x.span(),
            Self::RightShift(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::LeftShift => ShiftPrecOp::LeftShift(LeftShift::build(inner, alloc)),
            Rule::RightShift => ShiftPrecOp::RightShift(RightShift::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule AddPrecOp
#[derive(Debug)]
pub enum AddPrecOp<'i> {
    Add(&'i Add<'i>),
    Subtract(&'i Subtract<'i>),
}

impl<'i> TypedRule<'i> for AddPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::AddPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Add(x) => x.span(),
            Self::Subtract(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Add => AddPrecOp::Add(Add::build(inner, alloc)),
            Rule::Subtract => AddPrecOp::Subtract(Subtract::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule MulPrecOp
#[derive(Debug)]
pub enum MulPrecOp<'i> {
    Multiply(&'i Multiply<'i>),
    Divide(&'i Divide<'i>),
    Modulus(&'i Modulus<'i>),
}

impl<'i> TypedRule<'i> for MulPrecOp<'i> {
    const UNTYPED_RULE: Rule = Rule::MulPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Multiply(x) => x.span(),
            Self::Divide(x) => x.span(),
            Self::Modulus(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Multiply => MulPrecOp::Multiply(Multiply::build(inner, alloc)),
            Rule::Divide => MulPrecOp::Divide(Divide::build(inner, alloc)),
            Rule::Modulus => MulPrecOp::Modulus(Modulus::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// enum rule UnaryOp
#[derive(Debug)]
pub enum UnaryOp<'i> {
    LogicalNot(&'i LogicalNot<'i>),
    BitwiseNot(&'i BitwiseNot<'i>),
    Negate(&'i Negate<'i>),
}

impl<'i> TypedRule<'i> for UnaryOp<'i> {
    const UNTYPED_RULE: Rule = Rule::UnaryOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LogicalNot(x) => x.span(),
            Self::BitwiseNot(x) => x.span(),
            Self::Negate(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::LogicalNot => UnaryOp::LogicalNot(LogicalNot::build(inner, alloc)),
            Rule::BitwiseNot => UnaryOp::BitwiseNot(BitwiseNot::build(inner, alloc)),
            Rule::Negate => UnaryOp::Negate(Negate::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule OpenParen
#[derive(Debug)]
pub struct OpenParen<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenParen<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenParen;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseParen
#[derive(Debug)]
pub struct CloseParen<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseParen<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseParen;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule QuestionMark
#[derive(Debug)]
pub struct QuestionMark<'i>(Span<'i>);

impl<'i> TypedRule<'i> for QuestionMark<'i> {
    const UNTYPED_RULE: Rule = Rule::QuestionMark;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Colon
#[derive(Debug)]
pub struct Colon<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Colon<'i> {
    const UNTYPED_RULE: Rule = Rule::Colon;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LogicalNot
#[derive(Debug)]
pub struct LogicalNot<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LogicalNot<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalNot;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseNot
#[derive(Debug)]
pub struct BitwiseNot<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseNot<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseNot;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Negate
#[derive(Debug)]
pub struct Negate<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Negate<'i> {
    const UNTYPED_RULE: Rule = Rule::Negate;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Add
#[derive(Debug)]
pub struct Add<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Add<'i> {
    const UNTYPED_RULE: Rule = Rule::Add;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Subtract
#[derive(Debug)]
pub struct Subtract<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Subtract<'i> {
    const UNTYPED_RULE: Rule = Rule::Subtract;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Multiply
#[derive(Debug)]
pub struct Multiply<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Multiply<'i> {
    const UNTYPED_RULE: Rule = Rule::Multiply;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Divide
#[derive(Debug)]
pub struct Divide<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Divide<'i> {
    const UNTYPED_RULE: Rule = Rule::Divide;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Modulus
#[derive(Debug)]
pub struct Modulus<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Modulus<'i> {
    const UNTYPED_RULE: Rule = Rule::Modulus;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LogicalAnd
#[derive(Debug)]
pub struct LogicalAnd<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LogicalAnd<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalAnd;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LogicalOr
#[derive(Debug)]
pub struct LogicalOr<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LogicalOr<'i> {
    const UNTYPED_RULE: Rule = Rule::LogicalOr;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseAnd
#[derive(Debug)]
pub struct BitwiseAnd<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseAnd<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseAnd;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseOr
#[derive(Debug)]
pub struct BitwiseOr<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseOr<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseOr;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule BitwiseXor
#[derive(Debug)]
pub struct BitwiseXor<'i>(Span<'i>);

impl<'i> TypedRule<'i> for BitwiseXor<'i> {
    const UNTYPED_RULE: Rule = Rule::BitwiseXor;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LeftShift
#[derive(Debug)]
pub struct LeftShift<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LeftShift<'i> {
    const UNTYPED_RULE: Rule = Rule::LeftShift;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule RightShift
#[derive(Debug)]
pub struct RightShift<'i>(Span<'i>);

impl<'i> TypedRule<'i> for RightShift<'i> {
    const UNTYPED_RULE: Rule = Rule::RightShift;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LessThanOrEqual
#[derive(Debug)]
pub struct LessThanOrEqual<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LessThanOrEqual<'i> {
    const UNTYPED_RULE: Rule = Rule::LessThanOrEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule GreaterThanOrEqual
#[derive(Debug)]
pub struct GreaterThanOrEqual<'i>(Span<'i>);

impl<'i> TypedRule<'i> for GreaterThanOrEqual<'i> {
    const UNTYPED_RULE: Rule = Rule::GreaterThanOrEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule LessThan
#[derive(Debug)]
pub struct LessThan<'i>(Span<'i>);

impl<'i> TypedRule<'i> for LessThan<'i> {
    const UNTYPED_RULE: Rule = Rule::LessThan;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule GreaterThan
#[derive(Debug)]
pub struct GreaterThan<'i>(Span<'i>);

impl<'i> TypedRule<'i> for GreaterThan<'i> {
    const UNTYPED_RULE: Rule = Rule::GreaterThan;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule Equal
#[derive(Debug)]
pub struct Equal<'i>(Span<'i>);

impl<'i> TypedRule<'i> for Equal<'i> {
    const UNTYPED_RULE: Rule = Rule::Equal;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NotEqual
#[derive(Debug)]
pub struct NotEqual<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NotEqual<'i> {
    const UNTYPED_RULE: Rule = Rule::NotEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// enum rule IntLiteral
#[derive(Debug)]
pub enum IntLiteral<'i> {
    CharLiteral(&'i CharLiteral<'i>),
    NumericLiteral(&'i NumericLiteral<'i>),
}

impl<'i> TypedRule<'i> for IntLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::IntLiteral;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::CharLiteral(x) => x.span(),
            Self::NumericLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::CharLiteral => IntLiteral::CharLiteral(CharLiteral::build(inner, alloc)),
            Rule::NumericLiteral => IntLiteral::NumericLiteral(NumericLiteral::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule CharLiteral
#[derive(Debug)]
pub struct CharLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CharLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::CharLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule singlequotedchar generates no code

/// atomic rule NumericLiteral
#[derive(Debug)]
pub struct NumericLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NumericLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::NumericLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule HexLiteral
#[derive(Debug)]
pub struct HexLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for HexLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::HexLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule OctalLiteral
#[derive(Debug)]
pub struct OctalLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OctalLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::OctalLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule DecimalLiteral
#[derive(Debug)]
pub struct DecimalLiteral<'i>(Span<'i>);

impl<'i> TypedRule<'i> for DecimalLiteral<'i> {
    const UNTYPED_RULE: Rule = Rule::DecimalLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule NumericSuffix
#[derive(Debug)]
pub struct NumericSuffix<'i>(Span<'i>);

impl<'i> TypedRule<'i> for NumericSuffix<'i> {
    const UNTYPED_RULE: Rule = Rule::NumericSuffix;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule QuotedString
#[derive(Debug)]
pub struct QuotedString<'i>(Span<'i>);

impl<'i> TypedRule<'i> for QuotedString<'i> {
    const UNTYPED_RULE: Rule = Rule::QuotedString;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

// silent rule doublequotedchar generates no code

/// sequence rule ByteString
#[derive(Debug)]
pub struct ByteString<'i> {
    pub _span: Span<'i>,
    pub opensquare: &'i OpenSquare<'i>,
    pub labelorhexbyte: &'i Vec<'i, &'i LabelOrHexByte<'i>>,
    pub closesquare: &'i CloseSquare<'i>,
}

impl<'i> TypedRule<'i> for ByteString<'i> {
    const UNTYPED_RULE: Rule = Rule::ByteString;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_opensquare = Vec::<&'i OpenSquare>::new_in(alloc);
        let mut _tmp_labelorhexbyte = Vec::<&'i LabelOrHexByte>::new_in(alloc);
        let mut _tmp_closesquare = Vec::<&'i CloseSquare>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenSquare => _tmp_opensquare.push(OpenSquare::build(child, alloc)),
                Rule::LabelOrHexByte => _tmp_labelorhexbyte.push(LabelOrHexByte::build(child, alloc)),
                Rule::CloseSquare => _tmp_closesquare.push(CloseSquare::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            opensquare: to_singleton(_tmp_opensquare),
            labelorhexbyte: alloc.alloc(_tmp_labelorhexbyte),
            closesquare: to_singleton(_tmp_closesquare),
        })
    }
}

/// enum rule LabelOrHexByte
#[derive(Debug)]
pub enum LabelOrHexByte<'i> {
    Label(&'i Label<'i>),
    HexByte(&'i HexByte<'i>),
}

impl<'i> TypedRule<'i> for LabelOrHexByte<'i> {
    const UNTYPED_RULE: Rule = Rule::LabelOrHexByte;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::HexByte(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {
            Rule::Label => LabelOrHexByte::Label(Label::build(inner, alloc)),
            Rule::HexByte => LabelOrHexByte::HexByte(HexByte::build(inner, alloc)),
            rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
        })
    }
}

/// atomic rule OpenSquare
#[derive(Debug)]
pub struct OpenSquare<'i>(Span<'i>);

impl<'i> TypedRule<'i> for OpenSquare<'i> {
    const UNTYPED_RULE: Rule = Rule::OpenSquare;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule CloseSquare
#[derive(Debug)]
pub struct CloseSquare<'i>(Span<'i>);

impl<'i> TypedRule<'i> for CloseSquare<'i> {
    const UNTYPED_RULE: Rule = Rule::CloseSquare;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// atomic rule HexByte
#[derive(Debug)]
pub struct HexByte<'i>(Span<'i>);

impl<'i> TypedRule<'i> for HexByte<'i> {
    const UNTYPED_RULE: Rule = Rule::HexByte;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}

/// sequence rule Incbin
#[derive(Debug)]
pub struct Incbin<'i> {
    pub _span: Span<'i>,
    pub slashincbin: &'i SlashIncbin<'i>,
    pub openparen: &'i OpenParen<'i>,
    pub incbinargs: &'i IncbinArgs<'i>,
    pub closeparen: &'i CloseParen<'i>,
}

impl<'i> TypedRule<'i> for Incbin<'i> {
    const UNTYPED_RULE: Rule = Rule::Incbin;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slashincbin = Vec::<&'i SlashIncbin>::new_in(alloc);
        let mut _tmp_openparen = Vec::<&'i OpenParen>::new_in(alloc);
        let mut _tmp_incbinargs = Vec::<&'i IncbinArgs>::new_in(alloc);
        let mut _tmp_closeparen = Vec::<&'i CloseParen>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashIncbin => _tmp_slashincbin.push(SlashIncbin::build(child, alloc)),
                Rule::OpenParen => _tmp_openparen.push(OpenParen::build(child, alloc)),
                Rule::IncbinArgs => _tmp_incbinargs.push(IncbinArgs::build(child, alloc)),
                Rule::CloseParen => _tmp_closeparen.push(CloseParen::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            slashincbin: to_singleton(_tmp_slashincbin),
            openparen: to_singleton(_tmp_openparen),
            incbinargs: to_singleton(_tmp_incbinargs),
            closeparen: to_singleton(_tmp_closeparen),
        })
    }
}

/// sequence rule IncbinArgs
#[derive(Debug)]
pub struct IncbinArgs<'i> {
    pub _span: Span<'i>,
    pub quotedstring: &'i QuotedString<'i>,
    pub comma: &'i Vec<'i, &'i Comma<'i>>,
    pub numericliteral: &'i Vec<'i, &'i NumericLiteral<'i>>,
}

impl<'i> TypedRule<'i> for IncbinArgs<'i> {
    const UNTYPED_RULE: Rule = Rule::IncbinArgs;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_quotedstring = Vec::<&'i QuotedString>::new_in(alloc);
        let mut _tmp_comma = Vec::<&'i Comma>::new_in(alloc);
        let mut _tmp_numericliteral = Vec::<&'i NumericLiteral>::new_in(alloc);

        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::QuotedString => _tmp_quotedstring.push(QuotedString::build(child, alloc)),
                Rule::Comma => _tmp_comma.push(Comma::build(child, alloc)),
                Rule::NumericLiteral => _tmp_numericliteral.push(NumericLiteral::build(child, alloc)),
                Rule::EOI => (),
                Rule::WHITESPACE => (),
                Rule::COMMENT => (),
                rule => panic!("unexpected rule {rule:?} within {:?}", Self::UNTYPED_RULE),
            }
        }
        alloc.alloc(Self {
            _span,
            quotedstring: to_singleton(_tmp_quotedstring),
            comma: alloc.alloc(_tmp_comma),
            numericliteral: alloc.alloc(_tmp_numericliteral),
        })
    }
}
