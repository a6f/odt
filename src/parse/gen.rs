//! Typed grammar generated by pestle from /Users/ambrose/src/odt/src/dts.pest
use super::Rule;
use bumpalo::collections::Vec;
use bumpalo::Bump;
use pest::iterators::Pair;
use pest::Span;
pub trait TypedRule<'i> {
    const RULE: Rule;
    fn span(&self) -> &Span<'i>;
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self;
}
fn to_singleton<T>(mut v: Vec<T>) -> T {
    match v.len() {
        1 => v.pop().unwrap(),
        n => panic!("expected exactly one item, got {n}"),
    }
}
fn to_option<T>(mut v: Vec<T>) -> Option<T> {
    match v.len() {
        0 => None,
        1 => v.pop(),
        n => panic!("expected at most one item, got {n}"),
    }
}
/// atomic rule WHITESPACE = (((" " | "\t") | "\r") | "\n")
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct WHITESPACE<'i>(Span<'i>);
impl<'i> TypedRule<'i> for WHITESPACE<'i> {
    const RULE: Rule = Rule::WHITESPACE;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// enum rule COMMENT = (BlockComment | LineComment)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum COMMENT<'i> {
    BlockComment(&'i BlockComment<'i>),
    LineComment(&'i LineComment<'i>),
}
impl<'i> TypedRule<'i> for COMMENT<'i> {
    const RULE: Rule = Rule::COMMENT;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::BlockComment(x) => x.span(),
            Self::LineComment(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::BlockComment => {
                        COMMENT::BlockComment(BlockComment::build(inner, alloc))
                    }
                    Rule::LineComment => {
                        COMMENT::LineComment(LineComment::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule BlockComment = (("/*" ~ (BlockComment | (!"*/" ~ ANY))*) ~ "*/")
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BlockComment<'i>(Span<'i>);
impl<'i> TypedRule<'i> for BlockComment<'i> {
    const RULE: Rule = Rule::BlockComment;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LineComment = ("//" ~ (!newline ~ ANY)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LineComment<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LineComment<'i> {
    const RULE: Rule = Rule::LineComment;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule DtsFile = ((SOI ~ Dts) ~ EOI)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DtsFile<'i> {
    pub _span: Span<'i>,
    pub dts: &'i Dts<'i>,
}
impl<'i> TypedRule<'i> for DtsFile<'i> {
    const RULE: Rule = Rule::DtsFile;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_dts = Vec::<&'i Dts>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Dts => _tmp_dts.push(Dts::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                dts: to_singleton(_tmp_dts),
            })
    }
}
/// sequence rule Dts = (((Header* ~ Include*) ~ Memreserve*) ~ TopDef*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Dts<'i> {
    pub _span: Span<'i>,
    pub header: &'i Vec<'i, &'i Header<'i>>,
    pub include: &'i Vec<'i, &'i Include<'i>>,
    pub memreserve: &'i Vec<'i, &'i Memreserve<'i>>,
    pub top_def: &'i Vec<'i, &'i TopDef<'i>>,
}
impl<'i> TypedRule<'i> for Dts<'i> {
    const RULE: Rule = Rule::Dts;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_header = Vec::<&'i Header>::new_in(alloc);
        let mut _tmp_include = Vec::<&'i Include>::new_in(alloc);
        let mut _tmp_memreserve = Vec::<&'i Memreserve>::new_in(alloc);
        let mut _tmp_top_def = Vec::<&'i TopDef>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Header => _tmp_header.push(Header::build(child, alloc)),
                Rule::Include => _tmp_include.push(Include::build(child, alloc)),
                Rule::Memreserve => _tmp_memreserve.push(Memreserve::build(child, alloc)),
                Rule::TopDef => _tmp_top_def.push(TopDef::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                header: alloc.alloc(_tmp_header),
                include: alloc.alloc(_tmp_include),
                memreserve: alloc.alloc(_tmp_memreserve),
                top_def: alloc.alloc(_tmp_top_def),
            })
    }
}
/// atomic rule Semicolon = ";"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Semicolon<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Semicolon<'i> {
    const RULE: Rule = Rule::Semicolon;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashBits = "/bits/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashBits<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashBits<'i> {
    const RULE: Rule = Rule::SlashBits;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashDeleteNode = "/delete-node/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashDeleteNode<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashDeleteNode<'i> {
    const RULE: Rule = Rule::SlashDeleteNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashDeleteProperty = "/delete-property/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashDeleteProperty<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashDeleteProperty<'i> {
    const RULE: Rule = Rule::SlashDeleteProperty;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashDtsV1 = "/dts-v1/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashDtsV1<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashDtsV1<'i> {
    const RULE: Rule = Rule::SlashDtsV1;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashIncbin = "/incbin/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashIncbin<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashIncbin<'i> {
    const RULE: Rule = Rule::SlashIncbin;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashInclude = "/include/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashInclude<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashInclude<'i> {
    const RULE: Rule = Rule::SlashInclude;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashMemreserve = "/memreserve/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashMemreserve<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashMemreserve<'i> {
    const RULE: Rule = Rule::SlashMemreserve;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashOmitIfNoRef = "/omit-if-no-ref/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashOmitIfNoRef<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashOmitIfNoRef<'i> {
    const RULE: Rule = Rule::SlashOmitIfNoRef;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule SlashPlugin = "/plugin/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SlashPlugin<'i>(Span<'i>);
impl<'i> TypedRule<'i> for SlashPlugin<'i> {
    const RULE: Rule = Rule::SlashPlugin;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule Header = (Version ~ Plugin?)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Header<'i> {
    pub _span: Span<'i>,
    pub version: &'i Version<'i>,
    pub plugin: Option<&'i Plugin<'i>>,
}
impl<'i> TypedRule<'i> for Header<'i> {
    const RULE: Rule = Rule::Header;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_version = Vec::<&'i Version>::new_in(alloc);
        let mut _tmp_plugin = Vec::<&'i Plugin>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Version => _tmp_version.push(Version::build(child, alloc)),
                Rule::Plugin => _tmp_plugin.push(Plugin::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                version: to_singleton(_tmp_version),
                plugin: to_option(_tmp_plugin),
            })
    }
}
/// sequence rule Version = (SlashDtsV1 ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Version<'i> {
    pub _span: Span<'i>,
    pub slash_dts_v1: &'i SlashDtsV1<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for Version<'i> {
    const RULE: Rule = Rule::Version;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_dts_v1 = Vec::<&'i SlashDtsV1>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashDtsV1 => {
                    _tmp_slash_dts_v1.push(SlashDtsV1::build(child, alloc))
                }
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_dts_v1: to_singleton(_tmp_slash_dts_v1),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// sequence rule Plugin = (SlashPlugin ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Plugin<'i> {
    pub _span: Span<'i>,
    pub slash_plugin: &'i SlashPlugin<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for Plugin<'i> {
    const RULE: Rule = Rule::Plugin;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_plugin = Vec::<&'i SlashPlugin>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashPlugin => {
                    _tmp_slash_plugin.push(SlashPlugin::build(child, alloc))
                }
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_plugin: to_singleton(_tmp_slash_plugin),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// sequence rule Include = ((SlashInclude ~ IncludeWhitespace) ~ QuotedString)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Include<'i> {
    pub _span: Span<'i>,
    pub slash_include: &'i SlashInclude<'i>,
    pub include_whitespace: &'i IncludeWhitespace<'i>,
    pub quoted_string: &'i QuotedString<'i>,
}
impl<'i> TypedRule<'i> for Include<'i> {
    const RULE: Rule = Rule::Include;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_include = Vec::<&'i SlashInclude>::new_in(alloc);
        let mut _tmp_include_whitespace = Vec::<&'i IncludeWhitespace>::new_in(alloc);
        let mut _tmp_quoted_string = Vec::<&'i QuotedString>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashInclude => {
                    _tmp_slash_include.push(SlashInclude::build(child, alloc))
                }
                Rule::IncludeWhitespace => {
                    _tmp_include_whitespace.push(IncludeWhitespace::build(child, alloc))
                }
                Rule::QuotedString => {
                    _tmp_quoted_string.push(QuotedString::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_include: to_singleton(_tmp_slash_include),
                include_whitespace: to_singleton(_tmp_include_whitespace),
                quoted_string: to_singleton(_tmp_quoted_string),
            })
    }
}
/// atomic rule IncludeWhitespace = WHITESPACE*
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IncludeWhitespace<'i>(Span<'i>);
impl<'i> TypedRule<'i> for IncludeWhitespace<'i> {
    const RULE: Rule = Rule::IncludeWhitespace;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule Memreserve = ((((Label* ~ SlashMemreserve) ~ MemreserveArg) ~ MemreserveArg) ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Memreserve<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub slash_memreserve: &'i SlashMemreserve<'i>,
    pub memreserve_arg: &'i Vec<'i, &'i MemreserveArg<'i>>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for Memreserve<'i> {
    const RULE: Rule = Rule::Memreserve;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_slash_memreserve = Vec::<&'i SlashMemreserve>::new_in(alloc);
        let mut _tmp_memreserve_arg = Vec::<&'i MemreserveArg>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::SlashMemreserve => {
                    _tmp_slash_memreserve.push(SlashMemreserve::build(child, alloc))
                }
                Rule::MemreserveArg => {
                    _tmp_memreserve_arg.push(MemreserveArg::build(child, alloc))
                }
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                label: alloc.alloc(_tmp_label),
                slash_memreserve: to_singleton(_tmp_slash_memreserve),
                memreserve_arg: alloc.alloc(_tmp_memreserve_arg),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// enum rule MemreserveArg = (ParenExpr | IntLiteral)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum MemreserveArg<'i> {
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}
impl<'i> TypedRule<'i> for MemreserveArg<'i> {
    const RULE: Rule = Rule::MemreserveArg;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::ParenExpr => {
                        MemreserveArg::ParenExpr(ParenExpr::build(inner, alloc))
                    }
                    Rule::IntLiteral => {
                        MemreserveArg::IntLiteral(IntLiteral::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule TopDef = ((TopDelNode | TopOmitNode) | TopNode)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum TopDef<'i> {
    TopDelNode(&'i TopDelNode<'i>),
    TopOmitNode(&'i TopOmitNode<'i>),
    TopNode(&'i TopNode<'i>),
}
impl<'i> TypedRule<'i> for TopDef<'i> {
    const RULE: Rule = Rule::TopDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::TopDelNode(x) => x.span(),
            Self::TopOmitNode(x) => x.span(),
            Self::TopNode(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::TopDelNode => {
                        TopDef::TopDelNode(TopDelNode::build(inner, alloc))
                    }
                    Rule::TopOmitNode => {
                        TopDef::TopOmitNode(TopOmitNode::build(inner, alloc))
                    }
                    Rule::TopNode => TopDef::TopNode(TopNode::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// sequence rule TopDelNode = ((SlashDeleteNode ~ NodeReference) ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TopDelNode<'i> {
    pub _span: Span<'i>,
    pub slash_delete_node: &'i SlashDeleteNode<'i>,
    pub node_reference: &'i NodeReference<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for TopDelNode<'i> {
    const RULE: Rule = Rule::TopDelNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_delete_node = Vec::<&'i SlashDeleteNode>::new_in(alloc);
        let mut _tmp_node_reference = Vec::<&'i NodeReference>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashDeleteNode => {
                    _tmp_slash_delete_node.push(SlashDeleteNode::build(child, alloc))
                }
                Rule::NodeReference => {
                    _tmp_node_reference.push(NodeReference::build(child, alloc))
                }
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_delete_node: to_singleton(_tmp_slash_delete_node),
                node_reference: to_singleton(_tmp_node_reference),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// sequence rule TopOmitNode = ((SlashOmitIfNoRef ~ NodeReference) ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TopOmitNode<'i> {
    pub _span: Span<'i>,
    pub slash_omit_if_no_ref: &'i SlashOmitIfNoRef<'i>,
    pub node_reference: &'i NodeReference<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for TopOmitNode<'i> {
    const RULE: Rule = Rule::TopOmitNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_omit_if_no_ref = Vec::<&'i SlashOmitIfNoRef>::new_in(alloc);
        let mut _tmp_node_reference = Vec::<&'i NodeReference>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashOmitIfNoRef => {
                    _tmp_slash_omit_if_no_ref.push(SlashOmitIfNoRef::build(child, alloc))
                }
                Rule::NodeReference => {
                    _tmp_node_reference.push(NodeReference::build(child, alloc))
                }
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_omit_if_no_ref: to_singleton(_tmp_slash_omit_if_no_ref),
                node_reference: to_singleton(_tmp_node_reference),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// sequence rule TopNode = ((Label* ~ TopNodeName) ~ NodeBody)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TopNode<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub top_node_name: &'i TopNodeName<'i>,
    pub node_body: &'i NodeBody<'i>,
}
impl<'i> TypedRule<'i> for TopNode<'i> {
    const RULE: Rule = Rule::TopNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_top_node_name = Vec::<&'i TopNodeName>::new_in(alloc);
        let mut _tmp_node_body = Vec::<&'i NodeBody>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::TopNodeName => {
                    _tmp_top_node_name.push(TopNodeName::build(child, alloc))
                }
                Rule::NodeBody => _tmp_node_body.push(NodeBody::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                label: alloc.alloc(_tmp_label),
                top_node_name: to_singleton(_tmp_top_node_name),
                node_body: to_singleton(_tmp_node_body),
            })
    }
}
/// enum rule TopNodeName = (RootNodeName | NodeReference)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum TopNodeName<'i> {
    RootNodeName(&'i RootNodeName<'i>),
    NodeReference(&'i NodeReference<'i>),
}
impl<'i> TypedRule<'i> for TopNodeName<'i> {
    const RULE: Rule = Rule::TopNodeName;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::RootNodeName(x) => x.span(),
            Self::NodeReference(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::RootNodeName => {
                        TopNodeName::RootNodeName(RootNodeName::build(inner, alloc))
                    }
                    Rule::NodeReference => {
                        TopNodeName::NodeReference(NodeReference::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule RootNodeName = ("/" ~ !((('A'..'Z') | ('a'..'z')) | ('0'..'9')))
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RootNodeName<'i>(Span<'i>);
impl<'i> TypedRule<'i> for RootNodeName<'i> {
    const RULE: Rule = Rule::RootNodeName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Label = (LabelName ~ ":")
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Label<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Label<'i> {
    const RULE: Rule = Rule::Label;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LabelName = (labelname_head ~ labelname_rest*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LabelName<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LabelName<'i> {
    const RULE: Rule = Rule::LabelName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule NodeReference = (("&" ~ LabelName) | (("&{" ~ NodePath) ~ "}"))
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NodeReference<'i>(Span<'i>);
impl<'i> TypedRule<'i> for NodeReference<'i> {
    const RULE: Rule = Rule::NodeReference;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule NodePath = nodepathchar+
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NodePath<'i>(Span<'i>);
impl<'i> TypedRule<'i> for NodePath<'i> {
    const RULE: Rule = Rule::NodePath;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule NodeBody = (((OpenNode ~ NodeContents) ~ CloseNode) ~ EndNode)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NodeBody<'i> {
    pub _span: Span<'i>,
    pub open_node: &'i OpenNode<'i>,
    pub node_contents: &'i NodeContents<'i>,
    pub close_node: &'i CloseNode<'i>,
    pub end_node: &'i EndNode<'i>,
}
impl<'i> TypedRule<'i> for NodeBody<'i> {
    const RULE: Rule = Rule::NodeBody;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_open_node = Vec::<&'i OpenNode>::new_in(alloc);
        let mut _tmp_node_contents = Vec::<&'i NodeContents>::new_in(alloc);
        let mut _tmp_close_node = Vec::<&'i CloseNode>::new_in(alloc);
        let mut _tmp_end_node = Vec::<&'i EndNode>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenNode => _tmp_open_node.push(OpenNode::build(child, alloc)),
                Rule::NodeContents => {
                    _tmp_node_contents.push(NodeContents::build(child, alloc))
                }
                Rule::CloseNode => _tmp_close_node.push(CloseNode::build(child, alloc)),
                Rule::EndNode => _tmp_end_node.push(EndNode::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                open_node: to_singleton(_tmp_open_node),
                node_contents: to_singleton(_tmp_node_contents),
                close_node: to_singleton(_tmp_close_node),
                end_node: to_singleton(_tmp_end_node),
            })
    }
}
/// atomic rule OpenNode = "{"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct OpenNode<'i>(Span<'i>);
impl<'i> TypedRule<'i> for OpenNode<'i> {
    const RULE: Rule = Rule::OpenNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule CloseNode = "}"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CloseNode<'i>(Span<'i>);
impl<'i> TypedRule<'i> for CloseNode<'i> {
    const RULE: Rule = Rule::CloseNode;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule EndNode = Semicolon
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct EndNode<'i> {
    pub _span: Span<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for EndNode<'i> {
    const RULE: Rule = Rule::EndNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// sequence rule NodeContents = (PropDef* ~ ChildDef*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NodeContents<'i> {
    pub _span: Span<'i>,
    pub prop_def: &'i Vec<'i, &'i PropDef<'i>>,
    pub child_def: &'i Vec<'i, &'i ChildDef<'i>>,
}
impl<'i> TypedRule<'i> for NodeContents<'i> {
    const RULE: Rule = Rule::NodeContents;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_prop_def = Vec::<&'i PropDef>::new_in(alloc);
        let mut _tmp_child_def = Vec::<&'i ChildDef>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::PropDef => _tmp_prop_def.push(PropDef::build(child, alloc)),
                Rule::ChildDef => _tmp_child_def.push(ChildDef::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                prop_def: alloc.alloc(_tmp_prop_def),
                child_def: alloc.alloc(_tmp_child_def),
            })
    }
}
/// enum rule PropDef = (DelProp | Prop)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum PropDef<'i> {
    DelProp(&'i DelProp<'i>),
    Prop(&'i Prop<'i>),
}
impl<'i> TypedRule<'i> for PropDef<'i> {
    const RULE: Rule = Rule::PropDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::DelProp(x) => x.span(),
            Self::Prop(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::DelProp => PropDef::DelProp(DelProp::build(inner, alloc)),
                    Rule::Prop => PropDef::Prop(Prop::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule ChildDef = (DelNode | ChildNode)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ChildDef<'i> {
    DelNode(&'i DelNode<'i>),
    ChildNode(&'i ChildNode<'i>),
}
impl<'i> TypedRule<'i> for ChildDef<'i> {
    const RULE: Rule = Rule::ChildDef;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::DelNode(x) => x.span(),
            Self::ChildNode(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::DelNode => ChildDef::DelNode(DelNode::build(inner, alloc)),
                    Rule::ChildNode => {
                        ChildDef::ChildNode(ChildNode::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// sequence rule DelNode = (((DelNodeSuperfluousPrefix* ~ SlashDeleteNode) ~ NodeName) ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DelNode<'i> {
    pub _span: Span<'i>,
    pub del_node_superfluous_prefix: &'i Vec<'i, &'i DelNodeSuperfluousPrefix<'i>>,
    pub slash_delete_node: &'i SlashDeleteNode<'i>,
    pub node_name: &'i NodeName<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for DelNode<'i> {
    const RULE: Rule = Rule::DelNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_del_node_superfluous_prefix = Vec::<
            &'i DelNodeSuperfluousPrefix,
        >::new_in(alloc);
        let mut _tmp_slash_delete_node = Vec::<&'i SlashDeleteNode>::new_in(alloc);
        let mut _tmp_node_name = Vec::<&'i NodeName>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::DelNodeSuperfluousPrefix => {
                    _tmp_del_node_superfluous_prefix
                        .push(DelNodeSuperfluousPrefix::build(child, alloc))
                }
                Rule::SlashDeleteNode => {
                    _tmp_slash_delete_node.push(SlashDeleteNode::build(child, alloc))
                }
                Rule::NodeName => _tmp_node_name.push(NodeName::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                del_node_superfluous_prefix: alloc
                    .alloc(_tmp_del_node_superfluous_prefix),
                slash_delete_node: to_singleton(_tmp_slash_delete_node),
                node_name: to_singleton(_tmp_node_name),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// enum rule DelNodeSuperfluousPrefix = (Label | SlashOmitIfNoRef)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum DelNodeSuperfluousPrefix<'i> {
    Label(&'i Label<'i>),
    SlashOmitIfNoRef(&'i SlashOmitIfNoRef<'i>),
}
impl<'i> TypedRule<'i> for DelNodeSuperfluousPrefix<'i> {
    const RULE: Rule = Rule::DelNodeSuperfluousPrefix;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::SlashOmitIfNoRef(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Label => {
                        DelNodeSuperfluousPrefix::Label(Label::build(inner, alloc))
                    }
                    Rule::SlashOmitIfNoRef => {
                        DelNodeSuperfluousPrefix::SlashOmitIfNoRef(
                            SlashOmitIfNoRef::build(inner, alloc),
                        )
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// sequence rule DelProp = (((DelPropSuperfluousPrefix* ~ SlashDeleteProperty) ~ PropName) ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DelProp<'i> {
    pub _span: Span<'i>,
    pub del_prop_superfluous_prefix: &'i Vec<'i, &'i DelPropSuperfluousPrefix<'i>>,
    pub slash_delete_property: &'i SlashDeleteProperty<'i>,
    pub prop_name: &'i PropName<'i>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for DelProp<'i> {
    const RULE: Rule = Rule::DelProp;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_del_prop_superfluous_prefix = Vec::<
            &'i DelPropSuperfluousPrefix,
        >::new_in(alloc);
        let mut _tmp_slash_delete_property = Vec::<
            &'i SlashDeleteProperty,
        >::new_in(alloc);
        let mut _tmp_prop_name = Vec::<&'i PropName>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::DelPropSuperfluousPrefix => {
                    _tmp_del_prop_superfluous_prefix
                        .push(DelPropSuperfluousPrefix::build(child, alloc))
                }
                Rule::SlashDeleteProperty => {
                    _tmp_slash_delete_property
                        .push(SlashDeleteProperty::build(child, alloc))
                }
                Rule::PropName => _tmp_prop_name.push(PropName::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                del_prop_superfluous_prefix: alloc
                    .alloc(_tmp_del_prop_superfluous_prefix),
                slash_delete_property: to_singleton(_tmp_slash_delete_property),
                prop_name: to_singleton(_tmp_prop_name),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// sequence rule DelPropSuperfluousPrefix = Label
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DelPropSuperfluousPrefix<'i> {
    pub _span: Span<'i>,
    pub label: &'i Label<'i>,
}
impl<'i> TypedRule<'i> for DelPropSuperfluousPrefix<'i> {
    const RULE: Rule = Rule::DelPropSuperfluousPrefix;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                label: to_singleton(_tmp_label),
            })
    }
}
/// sequence rule ChildNode = ((ChildNodePrefix* ~ NodeName) ~ NodeBody)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ChildNode<'i> {
    pub _span: Span<'i>,
    pub child_node_prefix: &'i Vec<'i, &'i ChildNodePrefix<'i>>,
    pub node_name: &'i NodeName<'i>,
    pub node_body: &'i NodeBody<'i>,
}
impl<'i> TypedRule<'i> for ChildNode<'i> {
    const RULE: Rule = Rule::ChildNode;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_child_node_prefix = Vec::<&'i ChildNodePrefix>::new_in(alloc);
        let mut _tmp_node_name = Vec::<&'i NodeName>::new_in(alloc);
        let mut _tmp_node_body = Vec::<&'i NodeBody>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ChildNodePrefix => {
                    _tmp_child_node_prefix.push(ChildNodePrefix::build(child, alloc))
                }
                Rule::NodeName => _tmp_node_name.push(NodeName::build(child, alloc)),
                Rule::NodeBody => _tmp_node_body.push(NodeBody::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                child_node_prefix: alloc.alloc(_tmp_child_node_prefix),
                node_name: to_singleton(_tmp_node_name),
                node_body: to_singleton(_tmp_node_body),
            })
    }
}
/// enum rule ChildNodePrefix = (Label | SlashOmitIfNoRef)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ChildNodePrefix<'i> {
    Label(&'i Label<'i>),
    SlashOmitIfNoRef(&'i SlashOmitIfNoRef<'i>),
}
impl<'i> TypedRule<'i> for ChildNodePrefix<'i> {
    const RULE: Rule = Rule::ChildNodePrefix;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::SlashOmitIfNoRef(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Label => ChildNodePrefix::Label(Label::build(inner, alloc)),
                    Rule::SlashOmitIfNoRef => {
                        ChildNodePrefix::SlashOmitIfNoRef(
                            SlashOmitIfNoRef::build(inner, alloc),
                        )
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule NodeName = ("\\"? ~ nodechar+)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NodeName<'i>(Span<'i>);
impl<'i> TypedRule<'i> for NodeName<'i> {
    const RULE: Rule = Rule::NodeName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule Prop = (((Label* ~ PropName) ~ (PropAssign ~ PropValue)?) ~ Semicolon)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Prop<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub prop_name: &'i PropName<'i>,
    pub prop_assign: Option<&'i PropAssign<'i>>,
    pub prop_value: Option<&'i PropValue<'i>>,
    pub semicolon: &'i Semicolon<'i>,
}
impl<'i> TypedRule<'i> for Prop<'i> {
    const RULE: Rule = Rule::Prop;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_prop_name = Vec::<&'i PropName>::new_in(alloc);
        let mut _tmp_prop_assign = Vec::<&'i PropAssign>::new_in(alloc);
        let mut _tmp_prop_value = Vec::<&'i PropValue>::new_in(alloc);
        let mut _tmp_semicolon = Vec::<&'i Semicolon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::PropName => _tmp_prop_name.push(PropName::build(child, alloc)),
                Rule::PropAssign => {
                    _tmp_prop_assign.push(PropAssign::build(child, alloc))
                }
                Rule::PropValue => _tmp_prop_value.push(PropValue::build(child, alloc)),
                Rule::Semicolon => _tmp_semicolon.push(Semicolon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                label: alloc.alloc(_tmp_label),
                prop_name: to_singleton(_tmp_prop_name),
                prop_assign: to_option(_tmp_prop_assign),
                prop_value: to_option(_tmp_prop_value),
                semicolon: to_singleton(_tmp_semicolon),
            })
    }
}
/// atomic rule PropAssign = "="
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PropAssign<'i>(Span<'i>);
impl<'i> TypedRule<'i> for PropAssign<'i> {
    const RULE: Rule = Rule::PropAssign;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule PropName = ("\\"? ~ propchar+)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PropName<'i>(Span<'i>);
impl<'i> TypedRule<'i> for PropName<'i> {
    const RULE: Rule = Rule::PropName;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule PropValue = (LabeledValue ~ (Comma ~ LabeledValue)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PropValue<'i> {
    pub _span: Span<'i>,
    pub labeled_value: &'i Vec<'i, &'i LabeledValue<'i>>,
    pub comma: &'i Vec<'i, &'i Comma<'i>>,
}
impl<'i> TypedRule<'i> for PropValue<'i> {
    const RULE: Rule = Rule::PropValue;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_labeled_value = Vec::<&'i LabeledValue>::new_in(alloc);
        let mut _tmp_comma = Vec::<&'i Comma>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LabeledValue => {
                    _tmp_labeled_value.push(LabeledValue::build(child, alloc))
                }
                Rule::Comma => _tmp_comma.push(Comma::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                labeled_value: alloc.alloc(_tmp_labeled_value),
                comma: alloc.alloc(_tmp_comma),
            })
    }
}
/// atomic rule Comma = ","
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Comma<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Comma<'i> {
    const RULE: Rule = Rule::Comma;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule LabeledValue = ((Label* ~ Value) ~ Label*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LabeledValue<'i> {
    pub _span: Span<'i>,
    pub label: &'i Vec<'i, &'i Label<'i>>,
    pub value: &'i Value<'i>,
}
impl<'i> TypedRule<'i> for LabeledValue<'i> {
    const RULE: Rule = Rule::LabeledValue;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_label = Vec::<&'i Label>::new_in(alloc);
        let mut _tmp_value = Vec::<&'i Value>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Label => _tmp_label.push(Label::build(child, alloc)),
                Rule::Value => _tmp_value.push(Value::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                label: alloc.alloc(_tmp_label),
                value: to_singleton(_tmp_value),
            })
    }
}
/// enum rule Value = ((((Cells | QuotedString) | NodeReference) | ByteString) | Incbin)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Value<'i> {
    Cells(&'i Cells<'i>),
    QuotedString(&'i QuotedString<'i>),
    NodeReference(&'i NodeReference<'i>),
    ByteString(&'i ByteString<'i>),
    Incbin(&'i Incbin<'i>),
}
impl<'i> TypedRule<'i> for Value<'i> {
    const RULE: Rule = Rule::Value;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Cells(x) => x.span(),
            Self::QuotedString(x) => x.span(),
            Self::NodeReference(x) => x.span(),
            Self::ByteString(x) => x.span(),
            Self::Incbin(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Cells => Value::Cells(Cells::build(inner, alloc)),
                    Rule::QuotedString => {
                        Value::QuotedString(QuotedString::build(inner, alloc))
                    }
                    Rule::NodeReference => {
                        Value::NodeReference(NodeReference::build(inner, alloc))
                    }
                    Rule::ByteString => {
                        Value::ByteString(ByteString::build(inner, alloc))
                    }
                    Rule::Incbin => Value::Incbin(Incbin::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// sequence rule Cells = (((Bits? ~ OpenCells) ~ LabelOrCell*) ~ CloseCells)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Cells<'i> {
    pub _span: Span<'i>,
    pub bits: Option<&'i Bits<'i>>,
    pub open_cells: &'i OpenCells<'i>,
    pub label_or_cell: &'i Vec<'i, &'i LabelOrCell<'i>>,
    pub close_cells: &'i CloseCells<'i>,
}
impl<'i> TypedRule<'i> for Cells<'i> {
    const RULE: Rule = Rule::Cells;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bits = Vec::<&'i Bits>::new_in(alloc);
        let mut _tmp_open_cells = Vec::<&'i OpenCells>::new_in(alloc);
        let mut _tmp_label_or_cell = Vec::<&'i LabelOrCell>::new_in(alloc);
        let mut _tmp_close_cells = Vec::<&'i CloseCells>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::Bits => _tmp_bits.push(Bits::build(child, alloc)),
                Rule::OpenCells => _tmp_open_cells.push(OpenCells::build(child, alloc)),
                Rule::LabelOrCell => {
                    _tmp_label_or_cell.push(LabelOrCell::build(child, alloc))
                }
                Rule::CloseCells => {
                    _tmp_close_cells.push(CloseCells::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                bits: to_option(_tmp_bits),
                open_cells: to_singleton(_tmp_open_cells),
                label_or_cell: alloc.alloc(_tmp_label_or_cell),
                close_cells: to_singleton(_tmp_close_cells),
            })
    }
}
/// sequence rule Bits = (SlashBits ~ NumericLiteral)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Bits<'i> {
    pub _span: Span<'i>,
    pub slash_bits: &'i SlashBits<'i>,
    pub numeric_literal: &'i NumericLiteral<'i>,
}
impl<'i> TypedRule<'i> for Bits<'i> {
    const RULE: Rule = Rule::Bits;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_bits = Vec::<&'i SlashBits>::new_in(alloc);
        let mut _tmp_numeric_literal = Vec::<&'i NumericLiteral>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashBits => _tmp_slash_bits.push(SlashBits::build(child, alloc)),
                Rule::NumericLiteral => {
                    _tmp_numeric_literal.push(NumericLiteral::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_bits: to_singleton(_tmp_slash_bits),
                numeric_literal: to_singleton(_tmp_numeric_literal),
            })
    }
}
/// enum rule LabelOrCell = (Label | Cell)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum LabelOrCell<'i> {
    Label(&'i Label<'i>),
    Cell(&'i Cell<'i>),
}
impl<'i> TypedRule<'i> for LabelOrCell<'i> {
    const RULE: Rule = Rule::LabelOrCell;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::Cell(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Label => LabelOrCell::Label(Label::build(inner, alloc)),
                    Rule::Cell => LabelOrCell::Cell(Cell::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule OpenCells = "<"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct OpenCells<'i>(Span<'i>);
impl<'i> TypedRule<'i> for OpenCells<'i> {
    const RULE: Rule = Rule::OpenCells;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule CloseCells = ">"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CloseCells<'i>(Span<'i>);
impl<'i> TypedRule<'i> for CloseCells<'i> {
    const RULE: Rule = Rule::CloseCells;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// enum rule Cell = ((NodeReference | ParenExpr) | IntLiteral)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Cell<'i> {
    NodeReference(&'i NodeReference<'i>),
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}
impl<'i> TypedRule<'i> for Cell<'i> {
    const RULE: Rule = Rule::Cell;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::NodeReference(x) => x.span(),
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::NodeReference => {
                        Cell::NodeReference(NodeReference::build(inner, alloc))
                    }
                    Rule::ParenExpr => Cell::ParenExpr(ParenExpr::build(inner, alloc)),
                    Rule::IntLiteral => Cell::IntLiteral(IntLiteral::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// sequence rule ParenExpr = ((OpenParen ~ Expr) ~ CloseParen)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ParenExpr<'i> {
    pub _span: Span<'i>,
    pub open_paren: &'i OpenParen<'i>,
    pub expr: &'i Expr<'i>,
    pub close_paren: &'i CloseParen<'i>,
}
impl<'i> TypedRule<'i> for ParenExpr<'i> {
    const RULE: Rule = Rule::ParenExpr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_open_paren = Vec::<&'i OpenParen>::new_in(alloc);
        let mut _tmp_expr = Vec::<&'i Expr>::new_in(alloc);
        let mut _tmp_close_paren = Vec::<&'i CloseParen>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenParen => _tmp_open_paren.push(OpenParen::build(child, alloc)),
                Rule::Expr => _tmp_expr.push(Expr::build(child, alloc)),
                Rule::CloseParen => {
                    _tmp_close_paren.push(CloseParen::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                open_paren: to_singleton(_tmp_open_paren),
                expr: to_singleton(_tmp_expr),
                close_paren: to_singleton(_tmp_close_paren),
            })
    }
}
/// sequence rule Expr = TernaryPrec
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Expr<'i> {
    pub _span: Span<'i>,
    pub ternary_prec: &'i TernaryPrec<'i>,
}
impl<'i> TypedRule<'i> for Expr<'i> {
    const RULE: Rule = Rule::Expr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_ternary_prec = Vec::<&'i TernaryPrec>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::TernaryPrec => {
                    _tmp_ternary_prec.push(TernaryPrec::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                ternary_prec: to_singleton(_tmp_ternary_prec),
            })
    }
}
/// sequence rule TernaryPrec = (LogicalOrPrec ~ (((QuestionMark ~ Expr) ~ Colon) ~ Expr)?)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TernaryPrec<'i> {
    pub _span: Span<'i>,
    pub logical_or_prec: &'i LogicalOrPrec<'i>,
    pub question_mark: Option<&'i QuestionMark<'i>>,
    pub expr: &'i Vec<'i, &'i Expr<'i>>,
    pub colon: Option<&'i Colon<'i>>,
}
impl<'i> TypedRule<'i> for TernaryPrec<'i> {
    const RULE: Rule = Rule::TernaryPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_logical_or_prec = Vec::<&'i LogicalOrPrec>::new_in(alloc);
        let mut _tmp_question_mark = Vec::<&'i QuestionMark>::new_in(alloc);
        let mut _tmp_expr = Vec::<&'i Expr>::new_in(alloc);
        let mut _tmp_colon = Vec::<&'i Colon>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LogicalOrPrec => {
                    _tmp_logical_or_prec.push(LogicalOrPrec::build(child, alloc))
                }
                Rule::QuestionMark => {
                    _tmp_question_mark.push(QuestionMark::build(child, alloc))
                }
                Rule::Expr => _tmp_expr.push(Expr::build(child, alloc)),
                Rule::Colon => _tmp_colon.push(Colon::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                logical_or_prec: to_singleton(_tmp_logical_or_prec),
                question_mark: to_option(_tmp_question_mark),
                expr: alloc.alloc(_tmp_expr),
                colon: to_option(_tmp_colon),
            })
    }
}
/// sequence rule LogicalOrPrec = (LogicalAndPrec ~ (LogicalOr ~ LogicalAndPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LogicalOrPrec<'i> {
    pub _span: Span<'i>,
    pub logical_and_prec: &'i Vec<'i, &'i LogicalAndPrec<'i>>,
    pub logical_or: &'i Vec<'i, &'i LogicalOr<'i>>,
}
impl<'i> TypedRule<'i> for LogicalOrPrec<'i> {
    const RULE: Rule = Rule::LogicalOrPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_logical_and_prec = Vec::<&'i LogicalAndPrec>::new_in(alloc);
        let mut _tmp_logical_or = Vec::<&'i LogicalOr>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::LogicalAndPrec => {
                    _tmp_logical_and_prec.push(LogicalAndPrec::build(child, alloc))
                }
                Rule::LogicalOr => _tmp_logical_or.push(LogicalOr::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                logical_and_prec: alloc.alloc(_tmp_logical_and_prec),
                logical_or: alloc.alloc(_tmp_logical_or),
            })
    }
}
/// sequence rule LogicalAndPrec = (BitwiseOrPrec ~ (LogicalAnd ~ BitwiseOrPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LogicalAndPrec<'i> {
    pub _span: Span<'i>,
    pub bitwise_or_prec: &'i Vec<'i, &'i BitwiseOrPrec<'i>>,
    pub logical_and: &'i Vec<'i, &'i LogicalAnd<'i>>,
}
impl<'i> TypedRule<'i> for LogicalAndPrec<'i> {
    const RULE: Rule = Rule::LogicalAndPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwise_or_prec = Vec::<&'i BitwiseOrPrec>::new_in(alloc);
        let mut _tmp_logical_and = Vec::<&'i LogicalAnd>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseOrPrec => {
                    _tmp_bitwise_or_prec.push(BitwiseOrPrec::build(child, alloc))
                }
                Rule::LogicalAnd => {
                    _tmp_logical_and.push(LogicalAnd::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                bitwise_or_prec: alloc.alloc(_tmp_bitwise_or_prec),
                logical_and: alloc.alloc(_tmp_logical_and),
            })
    }
}
/// sequence rule BitwiseOrPrec = (BitwiseXorPrec ~ (BitwiseOr ~ BitwiseXorPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseOrPrec<'i> {
    pub _span: Span<'i>,
    pub bitwise_xor_prec: &'i Vec<'i, &'i BitwiseXorPrec<'i>>,
    pub bitwise_or: &'i Vec<'i, &'i BitwiseOr<'i>>,
}
impl<'i> TypedRule<'i> for BitwiseOrPrec<'i> {
    const RULE: Rule = Rule::BitwiseOrPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwise_xor_prec = Vec::<&'i BitwiseXorPrec>::new_in(alloc);
        let mut _tmp_bitwise_or = Vec::<&'i BitwiseOr>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseXorPrec => {
                    _tmp_bitwise_xor_prec.push(BitwiseXorPrec::build(child, alloc))
                }
                Rule::BitwiseOr => _tmp_bitwise_or.push(BitwiseOr::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                bitwise_xor_prec: alloc.alloc(_tmp_bitwise_xor_prec),
                bitwise_or: alloc.alloc(_tmp_bitwise_or),
            })
    }
}
/// sequence rule BitwiseXorPrec = (BitwiseAndPrec ~ (BitwiseXor ~ BitwiseAndPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseXorPrec<'i> {
    pub _span: Span<'i>,
    pub bitwise_and_prec: &'i Vec<'i, &'i BitwiseAndPrec<'i>>,
    pub bitwise_xor: &'i Vec<'i, &'i BitwiseXor<'i>>,
}
impl<'i> TypedRule<'i> for BitwiseXorPrec<'i> {
    const RULE: Rule = Rule::BitwiseXorPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_bitwise_and_prec = Vec::<&'i BitwiseAndPrec>::new_in(alloc);
        let mut _tmp_bitwise_xor = Vec::<&'i BitwiseXor>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::BitwiseAndPrec => {
                    _tmp_bitwise_and_prec.push(BitwiseAndPrec::build(child, alloc))
                }
                Rule::BitwiseXor => {
                    _tmp_bitwise_xor.push(BitwiseXor::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                bitwise_and_prec: alloc.alloc(_tmp_bitwise_and_prec),
                bitwise_xor: alloc.alloc(_tmp_bitwise_xor),
            })
    }
}
/// sequence rule BitwiseAndPrec = (EqualPrec ~ (BitwiseAnd ~ EqualPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseAndPrec<'i> {
    pub _span: Span<'i>,
    pub equal_prec: &'i Vec<'i, &'i EqualPrec<'i>>,
    pub bitwise_and: &'i Vec<'i, &'i BitwiseAnd<'i>>,
}
impl<'i> TypedRule<'i> for BitwiseAndPrec<'i> {
    const RULE: Rule = Rule::BitwiseAndPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_equal_prec = Vec::<&'i EqualPrec>::new_in(alloc);
        let mut _tmp_bitwise_and = Vec::<&'i BitwiseAnd>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::EqualPrec => _tmp_equal_prec.push(EqualPrec::build(child, alloc)),
                Rule::BitwiseAnd => {
                    _tmp_bitwise_and.push(BitwiseAnd::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                equal_prec: alloc.alloc(_tmp_equal_prec),
                bitwise_and: alloc.alloc(_tmp_bitwise_and),
            })
    }
}
/// sequence rule EqualPrec = (ComparePrec ~ (EqualPrecOp ~ ComparePrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct EqualPrec<'i> {
    pub _span: Span<'i>,
    pub compare_prec: &'i Vec<'i, &'i ComparePrec<'i>>,
    pub equal_prec_op: &'i Vec<'i, &'i EqualPrecOp<'i>>,
}
impl<'i> TypedRule<'i> for EqualPrec<'i> {
    const RULE: Rule = Rule::EqualPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_compare_prec = Vec::<&'i ComparePrec>::new_in(alloc);
        let mut _tmp_equal_prec_op = Vec::<&'i EqualPrecOp>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ComparePrec => {
                    _tmp_compare_prec.push(ComparePrec::build(child, alloc))
                }
                Rule::EqualPrecOp => {
                    _tmp_equal_prec_op.push(EqualPrecOp::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                compare_prec: alloc.alloc(_tmp_compare_prec),
                equal_prec_op: alloc.alloc(_tmp_equal_prec_op),
            })
    }
}
/// sequence rule ComparePrec = (ShiftPrec ~ (ComparePrecOp ~ ShiftPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ComparePrec<'i> {
    pub _span: Span<'i>,
    pub shift_prec: &'i Vec<'i, &'i ShiftPrec<'i>>,
    pub compare_prec_op: &'i Vec<'i, &'i ComparePrecOp<'i>>,
}
impl<'i> TypedRule<'i> for ComparePrec<'i> {
    const RULE: Rule = Rule::ComparePrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_shift_prec = Vec::<&'i ShiftPrec>::new_in(alloc);
        let mut _tmp_compare_prec_op = Vec::<&'i ComparePrecOp>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::ShiftPrec => _tmp_shift_prec.push(ShiftPrec::build(child, alloc)),
                Rule::ComparePrecOp => {
                    _tmp_compare_prec_op.push(ComparePrecOp::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                shift_prec: alloc.alloc(_tmp_shift_prec),
                compare_prec_op: alloc.alloc(_tmp_compare_prec_op),
            })
    }
}
/// sequence rule ShiftPrec = (AddPrec ~ (ShiftPrecOp ~ AddPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ShiftPrec<'i> {
    pub _span: Span<'i>,
    pub add_prec: &'i Vec<'i, &'i AddPrec<'i>>,
    pub shift_prec_op: &'i Vec<'i, &'i ShiftPrecOp<'i>>,
}
impl<'i> TypedRule<'i> for ShiftPrec<'i> {
    const RULE: Rule = Rule::ShiftPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_add_prec = Vec::<&'i AddPrec>::new_in(alloc);
        let mut _tmp_shift_prec_op = Vec::<&'i ShiftPrecOp>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::AddPrec => _tmp_add_prec.push(AddPrec::build(child, alloc)),
                Rule::ShiftPrecOp => {
                    _tmp_shift_prec_op.push(ShiftPrecOp::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                add_prec: alloc.alloc(_tmp_add_prec),
                shift_prec_op: alloc.alloc(_tmp_shift_prec_op),
            })
    }
}
/// sequence rule AddPrec = (MulPrec ~ (AddPrecOp ~ MulPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct AddPrec<'i> {
    pub _span: Span<'i>,
    pub mul_prec: &'i Vec<'i, &'i MulPrec<'i>>,
    pub add_prec_op: &'i Vec<'i, &'i AddPrecOp<'i>>,
}
impl<'i> TypedRule<'i> for AddPrec<'i> {
    const RULE: Rule = Rule::AddPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_mul_prec = Vec::<&'i MulPrec>::new_in(alloc);
        let mut _tmp_add_prec_op = Vec::<&'i AddPrecOp>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::MulPrec => _tmp_mul_prec.push(MulPrec::build(child, alloc)),
                Rule::AddPrecOp => _tmp_add_prec_op.push(AddPrecOp::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                mul_prec: alloc.alloc(_tmp_mul_prec),
                add_prec_op: alloc.alloc(_tmp_add_prec_op),
            })
    }
}
/// sequence rule MulPrec = (UnaryPrec ~ (MulPrecOp ~ UnaryPrec)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct MulPrec<'i> {
    pub _span: Span<'i>,
    pub unary_prec: &'i Vec<'i, &'i UnaryPrec<'i>>,
    pub mul_prec_op: &'i Vec<'i, &'i MulPrecOp<'i>>,
}
impl<'i> TypedRule<'i> for MulPrec<'i> {
    const RULE: Rule = Rule::MulPrec;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_unary_prec = Vec::<&'i UnaryPrec>::new_in(alloc);
        let mut _tmp_mul_prec_op = Vec::<&'i MulPrecOp>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::UnaryPrec => _tmp_unary_prec.push(UnaryPrec::build(child, alloc)),
                Rule::MulPrecOp => _tmp_mul_prec_op.push(MulPrecOp::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                unary_prec: alloc.alloc(_tmp_unary_prec),
                mul_prec_op: alloc.alloc(_tmp_mul_prec_op),
            })
    }
}
/// enum rule UnaryPrec = ((UnaryExpr | ParenExpr) | IntLiteral)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum UnaryPrec<'i> {
    UnaryExpr(&'i UnaryExpr<'i>),
    ParenExpr(&'i ParenExpr<'i>),
    IntLiteral(&'i IntLiteral<'i>),
}
impl<'i> TypedRule<'i> for UnaryPrec<'i> {
    const RULE: Rule = Rule::UnaryPrec;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::UnaryExpr(x) => x.span(),
            Self::ParenExpr(x) => x.span(),
            Self::IntLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::UnaryExpr => {
                        UnaryPrec::UnaryExpr(UnaryExpr::build(inner, alloc))
                    }
                    Rule::ParenExpr => {
                        UnaryPrec::ParenExpr(ParenExpr::build(inner, alloc))
                    }
                    Rule::IntLiteral => {
                        UnaryPrec::IntLiteral(IntLiteral::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// sequence rule UnaryExpr = (UnaryOp ~ UnaryPrec)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct UnaryExpr<'i> {
    pub _span: Span<'i>,
    pub unary_op: &'i UnaryOp<'i>,
    pub unary_prec: &'i UnaryPrec<'i>,
}
impl<'i> TypedRule<'i> for UnaryExpr<'i> {
    const RULE: Rule = Rule::UnaryExpr;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_unary_op = Vec::<&'i UnaryOp>::new_in(alloc);
        let mut _tmp_unary_prec = Vec::<&'i UnaryPrec>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::UnaryOp => _tmp_unary_op.push(UnaryOp::build(child, alloc)),
                Rule::UnaryPrec => _tmp_unary_prec.push(UnaryPrec::build(child, alloc)),
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                unary_op: to_singleton(_tmp_unary_op),
                unary_prec: to_singleton(_tmp_unary_prec),
            })
    }
}
/// enum rule EqualPrecOp = (Equal | NotEqual)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum EqualPrecOp<'i> {
    Equal(&'i Equal<'i>),
    NotEqual(&'i NotEqual<'i>),
}
impl<'i> TypedRule<'i> for EqualPrecOp<'i> {
    const RULE: Rule = Rule::EqualPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Equal(x) => x.span(),
            Self::NotEqual(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Equal => EqualPrecOp::Equal(Equal::build(inner, alloc)),
                    Rule::NotEqual => {
                        EqualPrecOp::NotEqual(NotEqual::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule ComparePrecOp = (((LessThanOrEqual | GreaterThanOrEqual) | LessThan) | GreaterThan)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ComparePrecOp<'i> {
    LessThanOrEqual(&'i LessThanOrEqual<'i>),
    GreaterThanOrEqual(&'i GreaterThanOrEqual<'i>),
    LessThan(&'i LessThan<'i>),
    GreaterThan(&'i GreaterThan<'i>),
}
impl<'i> TypedRule<'i> for ComparePrecOp<'i> {
    const RULE: Rule = Rule::ComparePrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LessThanOrEqual(x) => x.span(),
            Self::GreaterThanOrEqual(x) => x.span(),
            Self::LessThan(x) => x.span(),
            Self::GreaterThan(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::LessThanOrEqual => {
                        ComparePrecOp::LessThanOrEqual(
                            LessThanOrEqual::build(inner, alloc),
                        )
                    }
                    Rule::GreaterThanOrEqual => {
                        ComparePrecOp::GreaterThanOrEqual(
                            GreaterThanOrEqual::build(inner, alloc),
                        )
                    }
                    Rule::LessThan => {
                        ComparePrecOp::LessThan(LessThan::build(inner, alloc))
                    }
                    Rule::GreaterThan => {
                        ComparePrecOp::GreaterThan(GreaterThan::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule ShiftPrecOp = (LeftShift | RightShift)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ShiftPrecOp<'i> {
    LeftShift(&'i LeftShift<'i>),
    RightShift(&'i RightShift<'i>),
}
impl<'i> TypedRule<'i> for ShiftPrecOp<'i> {
    const RULE: Rule = Rule::ShiftPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LeftShift(x) => x.span(),
            Self::RightShift(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::LeftShift => {
                        ShiftPrecOp::LeftShift(LeftShift::build(inner, alloc))
                    }
                    Rule::RightShift => {
                        ShiftPrecOp::RightShift(RightShift::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule AddPrecOp = (Add | Subtract)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum AddPrecOp<'i> {
    Add(&'i Add<'i>),
    Subtract(&'i Subtract<'i>),
}
impl<'i> TypedRule<'i> for AddPrecOp<'i> {
    const RULE: Rule = Rule::AddPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Add(x) => x.span(),
            Self::Subtract(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Add => AddPrecOp::Add(Add::build(inner, alloc)),
                    Rule::Subtract => AddPrecOp::Subtract(Subtract::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule MulPrecOp = ((Multiply | Divide) | Modulus)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum MulPrecOp<'i> {
    Multiply(&'i Multiply<'i>),
    Divide(&'i Divide<'i>),
    Modulus(&'i Modulus<'i>),
}
impl<'i> TypedRule<'i> for MulPrecOp<'i> {
    const RULE: Rule = Rule::MulPrecOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Multiply(x) => x.span(),
            Self::Divide(x) => x.span(),
            Self::Modulus(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Multiply => MulPrecOp::Multiply(Multiply::build(inner, alloc)),
                    Rule::Divide => MulPrecOp::Divide(Divide::build(inner, alloc)),
                    Rule::Modulus => MulPrecOp::Modulus(Modulus::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// enum rule UnaryOp = ((LogicalNot | BitwiseNot) | Negate)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum UnaryOp<'i> {
    LogicalNot(&'i LogicalNot<'i>),
    BitwiseNot(&'i BitwiseNot<'i>),
    Negate(&'i Negate<'i>),
}
impl<'i> TypedRule<'i> for UnaryOp<'i> {
    const RULE: Rule = Rule::UnaryOp;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::LogicalNot(x) => x.span(),
            Self::BitwiseNot(x) => x.span(),
            Self::Negate(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::LogicalNot => {
                        UnaryOp::LogicalNot(LogicalNot::build(inner, alloc))
                    }
                    Rule::BitwiseNot => {
                        UnaryOp::BitwiseNot(BitwiseNot::build(inner, alloc))
                    }
                    Rule::Negate => UnaryOp::Negate(Negate::build(inner, alloc)),
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule OpenParen = "("
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct OpenParen<'i>(Span<'i>);
impl<'i> TypedRule<'i> for OpenParen<'i> {
    const RULE: Rule = Rule::OpenParen;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule CloseParen = ")"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CloseParen<'i>(Span<'i>);
impl<'i> TypedRule<'i> for CloseParen<'i> {
    const RULE: Rule = Rule::CloseParen;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule QuestionMark = "?"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct QuestionMark<'i>(Span<'i>);
impl<'i> TypedRule<'i> for QuestionMark<'i> {
    const RULE: Rule = Rule::QuestionMark;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Colon = ":"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Colon<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Colon<'i> {
    const RULE: Rule = Rule::Colon;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LogicalNot = "!"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LogicalNot<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LogicalNot<'i> {
    const RULE: Rule = Rule::LogicalNot;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule BitwiseNot = "~"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseNot<'i>(Span<'i>);
impl<'i> TypedRule<'i> for BitwiseNot<'i> {
    const RULE: Rule = Rule::BitwiseNot;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Negate = "-"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Negate<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Negate<'i> {
    const RULE: Rule = Rule::Negate;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Add = "+"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Add<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Add<'i> {
    const RULE: Rule = Rule::Add;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Subtract = "-"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Subtract<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Subtract<'i> {
    const RULE: Rule = Rule::Subtract;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Multiply = "*"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Multiply<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Multiply<'i> {
    const RULE: Rule = Rule::Multiply;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Divide = "/"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Divide<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Divide<'i> {
    const RULE: Rule = Rule::Divide;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Modulus = "%"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Modulus<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Modulus<'i> {
    const RULE: Rule = Rule::Modulus;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LogicalAnd = "&&"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LogicalAnd<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LogicalAnd<'i> {
    const RULE: Rule = Rule::LogicalAnd;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LogicalOr = "||"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LogicalOr<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LogicalOr<'i> {
    const RULE: Rule = Rule::LogicalOr;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule BitwiseAnd = "&"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseAnd<'i>(Span<'i>);
impl<'i> TypedRule<'i> for BitwiseAnd<'i> {
    const RULE: Rule = Rule::BitwiseAnd;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule BitwiseOr = "|"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseOr<'i>(Span<'i>);
impl<'i> TypedRule<'i> for BitwiseOr<'i> {
    const RULE: Rule = Rule::BitwiseOr;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule BitwiseXor = "^"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitwiseXor<'i>(Span<'i>);
impl<'i> TypedRule<'i> for BitwiseXor<'i> {
    const RULE: Rule = Rule::BitwiseXor;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LeftShift = "<<"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LeftShift<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LeftShift<'i> {
    const RULE: Rule = Rule::LeftShift;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule RightShift = ">>"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RightShift<'i>(Span<'i>);
impl<'i> TypedRule<'i> for RightShift<'i> {
    const RULE: Rule = Rule::RightShift;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LessThanOrEqual = "<="
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LessThanOrEqual<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LessThanOrEqual<'i> {
    const RULE: Rule = Rule::LessThanOrEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule GreaterThanOrEqual = ">="
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GreaterThanOrEqual<'i>(Span<'i>);
impl<'i> TypedRule<'i> for GreaterThanOrEqual<'i> {
    const RULE: Rule = Rule::GreaterThanOrEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule LessThan = "<"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LessThan<'i>(Span<'i>);
impl<'i> TypedRule<'i> for LessThan<'i> {
    const RULE: Rule = Rule::LessThan;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule GreaterThan = ">"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GreaterThan<'i>(Span<'i>);
impl<'i> TypedRule<'i> for GreaterThan<'i> {
    const RULE: Rule = Rule::GreaterThan;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule Equal = "=="
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Equal<'i>(Span<'i>);
impl<'i> TypedRule<'i> for Equal<'i> {
    const RULE: Rule = Rule::Equal;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule NotEqual = "!="
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NotEqual<'i>(Span<'i>);
impl<'i> TypedRule<'i> for NotEqual<'i> {
    const RULE: Rule = Rule::NotEqual;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// enum rule IntLiteral = (CharLiteral | NumericLiteral)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum IntLiteral<'i> {
    CharLiteral(&'i CharLiteral<'i>),
    NumericLiteral(&'i NumericLiteral<'i>),
}
impl<'i> TypedRule<'i> for IntLiteral<'i> {
    const RULE: Rule = Rule::IntLiteral;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::CharLiteral(x) => x.span(),
            Self::NumericLiteral(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::CharLiteral => {
                        IntLiteral::CharLiteral(CharLiteral::build(inner, alloc))
                    }
                    Rule::NumericLiteral => {
                        IntLiteral::NumericLiteral(NumericLiteral::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule CharLiteral = (("'" ~ singlequotedchar*) ~ "'")
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CharLiteral<'i>(Span<'i>);
impl<'i> TypedRule<'i> for CharLiteral<'i> {
    const RULE: Rule = Rule::CharLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule NumericLiteral = (((HexLiteral | OctalLiteral) | DecimalLiteral) ~ NumericSuffix?)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NumericLiteral<'i>(Span<'i>);
impl<'i> TypedRule<'i> for NumericLiteral<'i> {
    const RULE: Rule = Rule::NumericLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule HexLiteral = (^"0x" ~ ((('0'..'9') | ('A'..'F')) | ('a'..'f'))*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct HexLiteral<'i>(Span<'i>);
impl<'i> TypedRule<'i> for HexLiteral<'i> {
    const RULE: Rule = Rule::HexLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule OctalLiteral = ("0" ~ ('0'..'7')*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct OctalLiteral<'i>(Span<'i>);
impl<'i> TypedRule<'i> for OctalLiteral<'i> {
    const RULE: Rule = Rule::OctalLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule DecimalLiteral = (('1'..'9') ~ ('0'..'9')*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DecimalLiteral<'i>(Span<'i>);
impl<'i> TypedRule<'i> for DecimalLiteral<'i> {
    const RULE: Rule = Rule::DecimalLiteral;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule NumericSuffix = (((("ULL" | "LL") | "UL") | "L") | "U")
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NumericSuffix<'i>(Span<'i>);
impl<'i> TypedRule<'i> for NumericSuffix<'i> {
    const RULE: Rule = Rule::NumericSuffix;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule QuotedString = (("\"" ~ doublequotedchar*) ~ "\"")
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct QuotedString<'i>(Span<'i>);
impl<'i> TypedRule<'i> for QuotedString<'i> {
    const RULE: Rule = Rule::QuotedString;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule ByteString = ((OpenSquare ~ LabelOrHexByte*) ~ CloseSquare)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ByteString<'i> {
    pub _span: Span<'i>,
    pub open_square: &'i OpenSquare<'i>,
    pub label_or_hex_byte: &'i Vec<'i, &'i LabelOrHexByte<'i>>,
    pub close_square: &'i CloseSquare<'i>,
}
impl<'i> TypedRule<'i> for ByteString<'i> {
    const RULE: Rule = Rule::ByteString;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_open_square = Vec::<&'i OpenSquare>::new_in(alloc);
        let mut _tmp_label_or_hex_byte = Vec::<&'i LabelOrHexByte>::new_in(alloc);
        let mut _tmp_close_square = Vec::<&'i CloseSquare>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::OpenSquare => {
                    _tmp_open_square.push(OpenSquare::build(child, alloc))
                }
                Rule::LabelOrHexByte => {
                    _tmp_label_or_hex_byte.push(LabelOrHexByte::build(child, alloc))
                }
                Rule::CloseSquare => {
                    _tmp_close_square.push(CloseSquare::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                open_square: to_singleton(_tmp_open_square),
                label_or_hex_byte: alloc.alloc(_tmp_label_or_hex_byte),
                close_square: to_singleton(_tmp_close_square),
            })
    }
}
/// enum rule LabelOrHexByte = (Label | HexByte)
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum LabelOrHexByte<'i> {
    Label(&'i Label<'i>),
    HexByte(&'i HexByte<'i>),
}
impl<'i> TypedRule<'i> for LabelOrHexByte<'i> {
    const RULE: Rule = Rule::LabelOrHexByte;
    fn span(&self) -> &Span<'i> {
        match self {
            Self::Label(x) => x.span(),
            Self::HexByte(x) => x.span(),
        }
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc
            .alloc(
                match inner.as_rule() {
                    Rule::Label => LabelOrHexByte::Label(Label::build(inner, alloc)),
                    Rule::HexByte => {
                        LabelOrHexByte::HexByte(HexByte::build(inner, alloc))
                    }
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                },
            )
    }
}
/// atomic rule OpenSquare = "["
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct OpenSquare<'i>(Span<'i>);
impl<'i> TypedRule<'i> for OpenSquare<'i> {
    const RULE: Rule = Rule::OpenSquare;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule CloseSquare = "]"
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CloseSquare<'i>(Span<'i>);
impl<'i> TypedRule<'i> for CloseSquare<'i> {
    const RULE: Rule = Rule::CloseSquare;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// atomic rule HexByte = ((('0'..'9') | ('A'..'F')) | ('a'..'f')){2}
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct HexByte<'i>(Span<'i>);
impl<'i> TypedRule<'i> for HexByte<'i> {
    const RULE: Rule = Rule::HexByte;
    fn span(&self) -> &Span<'i> {
        &self.0
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }
}
/// sequence rule Incbin = (((SlashIncbin ~ OpenParen) ~ IncbinArgs) ~ CloseParen)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Incbin<'i> {
    pub _span: Span<'i>,
    pub slash_incbin: &'i SlashIncbin<'i>,
    pub open_paren: &'i OpenParen<'i>,
    pub incbin_args: &'i IncbinArgs<'i>,
    pub close_paren: &'i CloseParen<'i>,
}
impl<'i> TypedRule<'i> for Incbin<'i> {
    const RULE: Rule = Rule::Incbin;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_slash_incbin = Vec::<&'i SlashIncbin>::new_in(alloc);
        let mut _tmp_open_paren = Vec::<&'i OpenParen>::new_in(alloc);
        let mut _tmp_incbin_args = Vec::<&'i IncbinArgs>::new_in(alloc);
        let mut _tmp_close_paren = Vec::<&'i CloseParen>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::SlashIncbin => {
                    _tmp_slash_incbin.push(SlashIncbin::build(child, alloc))
                }
                Rule::OpenParen => _tmp_open_paren.push(OpenParen::build(child, alloc)),
                Rule::IncbinArgs => {
                    _tmp_incbin_args.push(IncbinArgs::build(child, alloc))
                }
                Rule::CloseParen => {
                    _tmp_close_paren.push(CloseParen::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                slash_incbin: to_singleton(_tmp_slash_incbin),
                open_paren: to_singleton(_tmp_open_paren),
                incbin_args: to_singleton(_tmp_incbin_args),
                close_paren: to_singleton(_tmp_close_paren),
            })
    }
}
/// sequence rule IncbinArgs = (QuotedString ~ (Comma ~ NumericLiteral)*)
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IncbinArgs<'i> {
    pub _span: Span<'i>,
    pub quoted_string: &'i QuotedString<'i>,
    pub comma: &'i Vec<'i, &'i Comma<'i>>,
    pub numeric_literal: &'i Vec<'i, &'i NumericLiteral<'i>>,
}
impl<'i> TypedRule<'i> for IncbinArgs<'i> {
    const RULE: Rule = Rule::IncbinArgs;
    fn span(&self) -> &Span<'i> {
        &self._span
    }
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
        assert_eq!(Self::RULE, pair.as_rule());
        let _span = pair.as_span();
        let mut _tmp_quoted_string = Vec::<&'i QuotedString>::new_in(alloc);
        let mut _tmp_comma = Vec::<&'i Comma>::new_in(alloc);
        let mut _tmp_numeric_literal = Vec::<&'i NumericLiteral>::new_in(alloc);
        for child in pair.into_inner() {
            match child.as_rule() {
                Rule::QuotedString => {
                    _tmp_quoted_string.push(QuotedString::build(child, alloc))
                }
                Rule::Comma => _tmp_comma.push(Comma::build(child, alloc)),
                Rule::NumericLiteral => {
                    _tmp_numeric_literal.push(NumericLiteral::build(child, alloc))
                }
                _ => {}
            }
        }
        alloc
            .alloc(Self {
                _span,
                quoted_string: to_singleton(_tmp_quoted_string),
                comma: alloc.alloc(_tmp_comma),
                numeric_literal: alloc.alloc(_tmp_numeric_literal),
            })
    }
}
