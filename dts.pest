// A Parsing Expression Grammar for the Devicetree Source format.
//
// See https://devicetree-specification.readthedocs.io/en/stable/source-language.html.
//
// DIFF comments mark known differences from the grammar `dtc` accepts.
//
// TODO: maybe just drop all the features we don't want?  would sure make this simpler.

// Pest accepts the WHITESPACE and COMMENT rules between any other tokens
// outside an atomic rule (introduced with '@' or '$').
// We discard whitespace, so this rule is silent.
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = ${ block_comment | line_comment }
// We want to capture comments for pretty-printing, so these rules are not silent.
block_comment = { "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
// DIFF: dtc requires that line comments end with '\n'; can't place one at the end of a noeol file
line_comment = { ("//" ~ (!newline ~ ANY)*) }
newline = _{ "\n" | "\r\n" }

// Overall structure of a DTS file.
dtsfile = { SOI ~ dts ~ EOI }
dts = { version ~ plugin? ~ include* ~ memreserve* ~ (topnode ~ (topdelnode | topnode)*)? }
// TODO: #line directives?

semicolon = { ";" }
slash_dts_v1 = { "/dts-v1/" }
slash_include = { "/include/" }
slash_delete_node = { "/delete-node/" }
slash_delete_property = { "/delete-property/" }
slash_bits = { "/bits/" }
slash_memreserve = { "/memreserve/" }
slash_omit_if_no_ref = { "/omit-if-no-ref/" }
slash_plugin = { "/plugin/" }
// TODO: incbin?  looks like dtc accepts
//   /incbin/ ("filename")
//   /incbin/ ("filename", start, len)
// in a propvalue?

version = { slash_dts_v1 ~ semicolon }

// DIFF: accepts /include/ anywhere, not just at file scope
include = ${ slash_include ~ horizontal_whitespace ~ include_path }
horizontal_whitespace = _{ (" " | "\t")* }
include_path = @{ string }

plugin = { slash_plugin ~ semicolon }

memreserve = { label* ~ slash_memreserve ~ expr ~ expr ~ semicolon }

topdelnode = { slash_delete_node ~ noderef ~ semicolon }
topomitnode = { slash_omit_if_no_ref ~ noderef ~ semicolon }

// DIFF: dtc forbids labeling the first topnode
topnode = { label* ~ ( rootnode | noderef ) ~ nodebody }
rootnode = { "/" }

label = @{ labelname ~ ":" }
labelname = @{ labelname_head ~ labelname_rest* }
labelname_head = { 'A'..'Z' | "_" | 'a'..'z' }
labelname_rest = { 'A'..'Z' | "_" | 'a'..'z' | '0'..'9' }

noderef = @{ ("&" ~ labelname) | ("&{" ~ nodepath ~ "}") }

nodepath = @{ ("/" ~ nodename)+ | "/" }
// TODO:  Maybe don't enforce @ placement in the parser.
nodename = @{ nodename_head ~ nodename_rest* ~ ("@" ~ nodename_rest*)? }
nodename_head = { 'A'..'Z' | 'a'..'z' }
nodename_rest = { 'A'..'Z' | 'a'..'z' | '0'..'9' | "," | "." | "_" | "+" | "-" }

nodebody = { open_node ~ nodecontents ~ close_node ~ semicolon }
open_node = { "{" }
close_node = { "}" }
nodecontents = { propdef* ~ childdef* }
propdef = { delprop | property }
childdef = { delnode | childnode }
// DIFF: dtc allows labeling /delete-node/, which is pointless
// DIFF: dtc allows /omit-if-no-ref/ on /delete-node/, which is pointless
delnode = { slash_delete_node ~ nodename ~ semicolon }
// DIFF: dtc allows labeling /delete-property/, which is pointless
delprop = { slash_delete_property ~ propname  ~ semicolon }

childnode = { (label | slash_omit_if_no_ref)* ~ nodename ~ nodebody }

property = { label* ~ propname ~ (propassign ~ propvalue)? ~ semicolon }
propassign = { "=" }

propname = @{ ( 'A'..'Z' | 'a'..'z' | '0'..'9' | "," | "." | "_" | "+" | "-" | "?" | "#" | "*" )+ }

// TODO: "/bits/", see https://stackoverflow.com/a/74074718
propvalue = { (value ~ comma)* ~ value }
comma = { "," }
// TODO: interior labels, trailing labels
value = _{ cells | string | noderef | bytestring }

cells = { open_cells ~ (cell)* ~ close_cells }
open_cells = { "<" }
close_cells = { ">" }

cell = { phandle | expr }

phandle = @{ noderef }

// TODO: operator precedence.  dtc-parser.y uses more intermediate nodes.
expr = { paren_expr | unary_expr | binary_expr | ternary_expr | number }
paren_expr = { open_paren ~ expr ~ close_paren }
unary_expr = { unary_op ~ expr }
binary_expr = { (paren_expr | unary_expr | number) ~ binary_op ~ expr }
ternary_expr = { (paren_expr | unary_expr | number) ~ question ~ expr ~ colon ~ expr }
unary_op = { logical_not | bitwise_not }
binary_op = { binary_arithmetic_op | binary_logical_op | binary_relational_op }
binary_arithmetic_op = { add | subtract | multiply | divide | modulus }
binary_logical_op = { logical_and | logical_or | bitwise_and | bitwise_or | bitwise_xor | left_shift | right_shift }
binary_relational_op = { less_than_or_equal | greater_than_or_equal | less_than | greater_than | equal | not_equal }
open_paren = { "(" }
close_paren = { ")" }
question = { "?" }
colon = { ":" }
logical_not = { "!" }
bitwise_not = { "~" }
add = { "+" }
subtract = { "-" }
multiply = { "*" }
divide = { "/" }
modulus = { "%" }
logical_and = { "&&" }
logical_or = { "||" }
bitwise_and = { "&" }
bitwise_or = { "|" }
bitwise_xor = { "^" }
left_shift = { "<<" }
right_shift = { ">>" }
less_than_or_equal = { "<=" }
greater_than_or_equal = { ">=" }
less_than = { "<" }
greater_than = { ">" }
equal = { "==" }
not_equal = { "!=" }

// TODO: numbers take a trailing (U|L|UL|LL|ULL)
number = @{ char_literal | hexadecimal | octal | decimal }
// DIFF: dtc doesn't accept '\\'
char_literal = @{ "'" ~ ( !("'" | "\\") ~ ANY | "\\" ~ ANY ) ~ "'" }
hexadecimal = @{ ^"0x" ~ ('0'..'9' | 'A'..'F' | 'a'..'f')* }
octal = @{ "0" ~ ('0'..'7')* }
decimal = @{ '1'..'9' ~ ('0'..'9')* }

string = @{ "\"" ~ stringchar* ~ "\"" }
stringchar = @{ !("\"" | "\\") ~ ANY | "\\" ~ ANY }

bytestring = { open_square ~ hexbyte* ~ close_square }
open_square = { "[" }
close_square = { "]" }
hexbyte = @{ ('0'..'9' | 'A'..'F' | 'a'..'f'){2} }
